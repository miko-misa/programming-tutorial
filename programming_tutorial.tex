\documentclass[a4paper]{ltjsreport}
\usepackage[top=17truemm,bottom=17truemm,left=11truemm,right=11truemm]{geometry}

\usepackage{fancyhdr}
\usepackage{color}
\usepackage{xcolor}
\usepackage{listings}
\usepackage{lastpage}
\usepackage{hyperref}
\usepackage{enumerate}
\usepackage{tcolorbox}
\tcbuselibrary{breakable, skins}
\usepackage{luacode}
\usepackage{etoolbox}
\usepackage{bxbase}
\usepackage{luatexja-otf}
\usepackage{amsmath}
\usepackage{amssymb}

\makeatletter
\patchcmd{\lsthk@SelectCharTable}{\lst@ifbreaklines\lst@Def{`)}{\lst@breakProcessOther)}\fi}{}{}{} % '
\makeatother
\title{programming-tutorial}
\author{博ノ助 }
\date{June 2023}


\definecolor{terlogy}{HTML}{ebebeb}
\newcommand{\terlogy}[2][|]{\colorbox{terlogy}{\texttt{\lstinline#1#2#1}}}

% 背景色
\definecolor{bg}{HTML}{1a2638}
% タイトルの背景色
\definecolor{titlebg}{HTML}{323e52}
% 以下シンタックスハイライト設定
% リテラルと演算記号
\definecolor{literal}{HTML}{efba69}
% 関数/変数の識別子（青）
\definecolor{identifier}{HTML}{35b7eb}
% コメント
\definecolor{comment}{HTML}{818ea0}
% 予約語
\definecolor{reserved}{HTML}{f88ca0}
% 区切り文字
\definecolor{delimiter}{HTML}{8a92b6}

\begin{luacode*}
function init()
  local numlist = ""
  for i = -100, 1000 do
    numlist = numlist .. tostring(i)
    if i < 1000 then
      numlist = numlist .. ", "
    end
  end
  output = [[
    \lstdefinelanguage{mypy}{
      morekeywords=[1]{+=,=,==,!=,!,>,<,>=,<=,++,-,+,*,\%,/, ]]..numlist..[[},
      morekeywords=[2]{False,{-}ne,True,and,as,assert,async,await,break,class,continue,def,del,elif,else,except,finally,for,from,global,if,import,in,is,lambda,nonlocal,not,or,pass,raise,return,try,while,with,yield,print,match,case},
      morekeywords=[3]{defined_func, division},
      literate=*{.}{{\color{delimiter}.}}1
                {,}{{\color{delimiter},}}1 {:}{{\color{delimiter}:}}1
                {)}{{\color{delimiter})}}1 {(}{{\color{delimiter}(}}1
                {[}{{\color{delimiter}[}}1 {]}{{\color{delimiter}]}}1
                {\{}{{\color{delimiter}\{}}1 {\}}{{\color{delimiter}\}}}1,
      sensitive=true,
      morecomment=[l]{\#},
      morestring=[b]{\'},
      morestring=[b]{\"},
      alsoletter={\%<>=+-*\/1234567890!},
      frame=none,
      breaklines=true,
      breakindent=12pt,
      columns=fixed,
      basewidth=0.5em,
      numbers=left,
      numberstyle={\scriptsize\color{white}},
      stepnumber=1,
      framexleftmargin=18pt,
      keepspaces=true,
      lineskip=-0.1ex,
      tabsize=4,
      backgroundcolor={},
      basicstyle={\small\ttfamily\color{white}},
      identifierstyle={\small\color{white}},
      commentstyle={\small\color{comment}},
      keywordstyle=[1]{\small\bfseries\color{literal}},
      keywordstyle=[2]{\small\bfseries\color{reserved}},
      keywordstyle=[3]{\small\bfseries\color{identifier}},
      keywordstyle=[4]{\small\bfseries\color{delimiter}},
      keywordstyle=[5]{\small\bfseries\color{keyword4}},
      stringstyle={\small\ttfamily\color{literal}},
    }

    \lstdefinelanguage{myjava}{
      morekeywords=[1]{+=,=,==,!=,!,>,<,>=,<=,++,-,+,*,\%,/, ]]..numlist..[[},
      morekeywords=[2]{abstract, assert, boolean, break, byte, case, catch, char, class, const, continue, default, do, double, else, enum, extends, final, finally, float, for, goto, if, implements, import, instanceof, int, interface, long, native, new, package, private, protected, public, return, short, static, strictfp, super, switch, synchronized, this, throw, throws, transient, try, void, volatile, while},
      morekeywords=[3]{println, myFunc},
      literate=*{.}{{\color{delimiter}.}}1
                {,}{{\color{delimiter},}}1 {;}{{\color{delimiter}:}}1
                {)}{{\color{delimiter})}}1 {(}{{\color{delimiter}(}}1
                {[}{{\color{delimiter}[}}1 {]}{{\color{delimiter}]}}1
                {\{}{{\color{delimiter}\{}}1 {\}}{{\color{delimiter}\}}}1,
      sensitive=true,
      morecomment=[l]{//},
      morestring=[b]{\'},
      morestring=[b]{\"},
      alsoletter={\%<>=+-*\/1234567890!},
      frame=none,
      breaklines=true,
      breakindent=12pt,
      columns=fixed,
      basewidth=0.5em,
      numbers=left,
      numberstyle={\scriptsize\color{white}},
      stepnumber=1,
      framexleftmargin=18pt,
      keepspaces=true,
      lineskip=-0.1ex,
      tabsize=4,
      backgroundcolor={},
      basicstyle={\small\ttfamily\color{white}},
      identifierstyle={\small\color{white}},
      commentstyle={\small\color{comment}},
      keywordstyle=[1]{\small\bfseries\color{literal}},
      keywordstyle=[2]{\small\bfseries\color{reserved}},
      keywordstyle=[3]{\small\bfseries\color{identifier}},
      keywordstyle=[4]{\small\bfseries\color{delimiter}},
      keywordstyle=[5]{\small\bfseries\color{keyword4}},
      stringstyle={\small\ttfamily\color{literal}},
    }

    \lstdefinelanguage{myphp}{
      morekeywords=[1]{+=,=,==,!=,!,>,<,>=,<=,++,-,+,*,\%,/, ]]..numlist..[[},
      morekeywords=[2]{<?php,?>,__halt_compiler, abstract, and, array, as, break, callable, case, catch, class, clone, const, continue, declare, default, die, do, echo, else, elseif, empty, enddeclare, endfor, endforeach, endif, endswitch, endwhile, eval, exit, extends, final, finally, for, foreach, function, global, goto, if, implements, include, include_once, instanceof, insteadof, interface, isset, list, namespace, new, or, print, private, protected, public, require, require_once, return, static, switch, throw, trait, try, unset, use, var, while, xor, yield
      },
      morekeywords=[3]{println, myFunc},
      literate=*{.}{{\color{delimiter}.}}1
                {,}{{\color{delimiter},}}1 {;}{{\color{delimiter}:}}1
                {)}{{\color{delimiter})}}1 {(}{{\color{delimiter}(}}1
                {[}{{\color{delimiter}[}}1 {]}{{\color{delimiter}]}}1
                {\{}{{\color{delimiter}\{}}1 {\}}{{\color{delimiter}\}}}1,
      sensitive=true,
      morecomment=[l]{//},
      morestring=[b]{\'},
      morestring=[b]{\"},
      alsoletter={\%<>=+-*\/1234567890!?},
      frame=none,
      breaklines=true,
      breakindent=12pt,
      columns=fixed,
      basewidth=0.5em,
      numbers=left,
      numberstyle={\scriptsize\color{white}},
      stepnumber=1,
      framexleftmargin=18pt,
      keepspaces=true,
      lineskip=-0.1ex,
      tabsize=4,
      backgroundcolor={},
      basicstyle={\small\ttfamily\color{white}},
      identifierstyle={\small\color{white}},
      commentstyle={\small\color{comment}},
      keywordstyle=[1]{\small\bfseries\color{literal}},
      keywordstyle=[2]{\small\bfseries\color{reserved}},
      keywordstyle=[3]{\small\bfseries\color{identifier}},
      keywordstyle=[4]{\small\bfseries\color{delimiter}},
      keywordstyle=[5]{\small\bfseries\color{keyword4}},
      stringstyle={\small\ttfamily\color{literal}},
    }
  ]]
  output_ = string.gsub(output, "\n", "")
  tex.sprint(output_)
end
\end{luacode*}

\directlua{init()}


\newtcolorbox{zennwt}[2][]{
    enhanced,                         %tikzを用いた記法の処理
    left=22pt,right=22pt,             %box内左右の余白
    fonttitle=\small,                 %タイトルの書式
    coltitle=white,                   %タイトルの文字の色
    colbacktitle=titlebg,             %タイトルの背景の色
    attach boxed title to top left={},%タイトルを左寄せに,少し微調整
    boxed title style={               %タイトルボックスの装飾
      skin=enhancedfirst jigsaw,
      arc=1.5mm,                      %タイトルボックスの角の弧
      bottom=0mm,
      boxrule=0mm
    },
    boxrule=0pt,                      %枠線の太さ
    colback=bg,                       %本文の背景色
    colframe=bg,                      %本文の枠の色
    sharp corners=northwest,          %左上の角の調整
    breakable,                        %ページ跨ぎOK
    title=\texttt{#2},                %タイトル
    arc=2.5mm,                        %角の弧の背景
    #1
}

\newtcolorbox{zenn}[1][]{
    left=22pt,right=22pt,
    boxrule=0pt,
    colback=bg,
    colframe=bg,
    breakable,
    arc=2.5mm,
    #1
}

\definecolor{columnbg}{HTML}{fff6e4}
\definecolor{columntitle}{HTML}{edcd8c}

\newtcolorbox{column}[2][]{
    enhanced,breakable, title=\textbf{#2}, attach boxed title to top left={xshift=3mm, yshift*=-\tcboxedtitleheight/2}
}

\makeatletter
\def\section{\@startsection {section}{1}{\z@}{-2.5ex plus -1ex minus -.2ex}{2.5 ex plus .2ex}{\Large \bfseries \sffamily}}
\def\subsection{\@startsection {subsection}{1}{\z@}{-1.5ex plus -1ex minus -.2ex}{2.3 ex plus .2ex}{\Large \sffamily}}
\def\subsubsection{\@startsection {subsubsection}{1}{\z@}{-2.5ex plus -1ex minus -.2ex}{.3 ex plus .2ex}{\large \sffamily}}

\def\teremp[#1]{\@ifnextchar[{\teremp@sec[#1]}{\textbf{ #1 }}}
\def\teremp@sec[#1][#2]{\;\textbf{#1\,(\texttt{#2})}\;}
\makeatother

\newcommand{\impact}[1]{\textbf\sffamily #1}
\newcommand{\mail}[2]{\href{mailto:#2}{#1}}
\newcommand{\link}[2]{\href{#2}{#1}}

\pagestyle{fancy}
\lhead{\fontsize{8pt}{0pt}\selectfont \hyperlink{top}{プログラミング入門}}
\rfoot{\copyright 博ノ助/miko-misa 2023}
\cfoot{\thepage/\pageref{LastPage}}

\newcommand{\Chapter}[1]{\chapter{#1}\thispagestyle{fancy}}

\begin{document}


\chapter*{はじめに}
コンピュータの開発から半世紀弱が経ちました.それとともに,コンピュータを制御する方法は指数関数的に進歩してきました.コンピュータの基本である「計算」を機械的に行おうという試みは紀元前から見られましたがコンピュータの計算の基本となる理論はつい100年ほど前に確立されました.\teremp[Alan Turing][1912-1954]は数学的「計算可能性」についての議論で,チューリングマシンを提案し,数学的に計算の手順を捉えるための基礎を築きました.第二次世界大戦では,暗号解読のためにさまざまな機械が開発されました.とくにドイツの暗号は複雑で,エニグマが有名ですが,それは機械式の解読機によって解読することができました.しかし,ヒトラーや将官たちが使用していた\teremp[ローレンツSZ42]による暗号はさらに複雑で,機械式の解読には時間がかかりすぎました.そこでイギリスで開発されたのが\teremp[コロッサス]です.コロッサスは真空管を使った電子計算機で,そのプログラムにはハードウェアで設定されたものが使用されました.戦争終結後,\teremp[ENIAC][Electronic Numerical Integrator and Computer]という世界初の汎用電子計算機が開発され,コンピュータの単純な計算能力としての役割がスタートしました.ただし,その時点ではプログラムはハードウェアによって与えられており,ソフトウェアという概念はまだ存在していませんでした.1950年代になると,高水準言語が開発され,人間はパンチカード（紙に穴を開け,穴の有無でプログラムを表す手法）やスイッチを使わずに,より人間の言語に近い形でプログラムを記述できるようになりました.また,プログラムをコンピュータ本体に保存し,再利用するバッチ処理の登場により,コンピュータの操作はソフトウェアによって行われるようになっていきました.やがてコンピュータは\teremp[パーソナルコンピュータ]として進化を遂げ,\teremp[AppleのMacintosh]によって\teremp[GUI][Graphic User Interface]が追加されたことにより多くの人に受け入れられる形となりました.
\\
\\
これはコンピュータの歴史であると同時に「コンピュータを制御する方法」の進化でもあります.プログラムはコンピュータを操作する唯一の方法ではありませんが,現代においてはほとんどすべてのコンピュータをプログラムで操作できるのです.コンピュータを操作し自分の能力を拡張することに関してプログラムは大きな役割を果たしてくれます.今日の情報化社会では大量の情報を処理することが求められており,プログラムはそれらを行ってくれる機械への道標となるのです.
\\
\\
本書では,「プログラムを書く」といった狭い視点ではなく「機械を正しく操作する」という大きな観点からプログラミングを俯瞰しその基本理念や具体的な考え方について解説します.本書ではわかりやさのため\teremp[Python]を念頭に解説をしますが,他の言語についても補助的に掲載しており,言語に縛られない理論について深く考察していくつもりです.この考察が貴方を言語による束縛から開放し,言語を超えた真の理解ができる一助となれば幸いです.


\setcounter{tocdepth}{3}
\tableofcontents

\Chapter{プログラミング言語}
\section{プログラミング言語とは}
プログラミング言語とは情報の構造を形成し,それが処理される---別のより最適な状態に変換されるタスクについてその内容を完全に記述できるルールのことです.つまりは,情報が存在するときにその情報をその情報足らしめている要因,そして情報が正しく移管されることを担保する要因,を記述するのがプログラミング言語です.これは非常に自然言語\footnote{
  人間が意思疎通のために日常的に用いる言語であり,文化的背景を持っておのずから発展してきた言語.日本語,英語,中国語などがこれに当たる.}に似ています.人間は情報伝達のツールとして言語を使用していますが,その情報が情報として人々の脳に存在するために言語が必要です.\footnote{哲学においては必ずしもクオリアは言語ベースではない可能性があるが,ここでは議論しない.}同様に伝達元と伝達先で同一の情報を受け取れるように担保しているのも言語というルールです.この性質上,プログラミング言語は自然言語をもとに定義されます.現に,多くのプログラミングはアルファベットで記述し使用する単語は英単語です.ただ,明確に違うのが情報=データが数字であることです.これはコンピュータが0と1の2進法で動作しているためであり,プログラミング言語が自然言語と一線を画している理由です.もちろん,世界はすべて数値で表せるわけではないので,コンピュータで扱われる「情報」は数値ベースで,曖昧さは一切ありません.なので自ずと情報を扱うプログラミング言語に曖昧さはなく,自然言語よりもより抽象化され,効率化されています.たとえば自然言語ではある程度文型が決まってることが多いですが,それを崩した形も頻繁に登場し,省略,倒置が頻繁に起こります.しかしプログラミング言語ではそもそも最適化されているので省略できない部分のみで構成されていますし,倒置\footnote{一見すると記述の順番が前後しているように見える場合があるが,これは「倒置」としての文法ルールではない.}は起こりません.すべてがいくつかの文法ルール上で成り立っています.

\section{言語の構成要素}
プログラミング言語がどのようなものかはわかりました.では具体的に言語はどのような要素で構成されているのでしょうか.わかりやすさのため,自然言語と対照させて考えてみましょう.自然言語は主に「文法」と「単語」で構成されているようです.それぞれの単語に品詞が存在し,品詞によって単語の役割が異なり,それを規定しているのが文法です.対してプログラミング言語は「文法」と「値」で構成されています.さきほどのセクションでプログラミングは情報を扱うものであると述べましたが,その「情報」となるのが「値」です.今の段階では0,1,2といった数字のことだとイメージしても構いません.
\\\\
では自然言語での「単語」はプログラミング言語ではどうなってしまったのでしょうか.それはすべて「定義」として「文法」に取り込まれています.プログラミング言語は効率的な言語なのでその場限りで定義を行うことができる文法が存在します.たとえば,自然言語でも「個々で言う〇〇とは△△のことである.」と断りを入れて新しい単語を使用する場面があります.プログラミング言語ではこういった定義が日常的に行われており,自分以外が定義したものを使うことができます.プログラムは「定義する」命令と「値を処理する」命令を繰り返すことで成り立っているのです.これがプログラミング言語最大の特徴です.他人があらかじめ定義してくれたものを使用し,新たなプログラムを制作することが可能でこういった他人の定義した要素を\teremp[ライブラリ]と呼びます.何十年を通して培われたライブラリ郡を簡単に使用できることがプログラミング言語を効率化させているだけでなく,プログラミング言語が急成長することができた要因の1つとなっているのです.
\\\\
また,プログラムを効率よく書くために,各言語に特定の記述を短縮できる特別な文法が用意されており,これを\teremp[糖衣構文][Syntactic Sugar]といいます.

\section{言語の多様化}
現在,世界的に頻繁使われるプログラミング言語は200種類以上存在します.なぜこのように多様な言語が共存しているのでしょうか.それは言語に向き不向き,つまり特徴があるからなのです.当然,プログラミング言語によってどのようにコーディング\footnote{実際にプログラミング言語を用いてプログラムを記述すること.}されるのかは大きく異なります.ただ,それだけではなく安全性や速度,実装するできる機能も大きく変わるのです.どんなプログラムでもエラーをはらんでいます.エラーが起きてしまった際にどのように処理をするのかということは非常に重要ですが,エラーを防ぐような仕組みが存在する言語もあります.そういった言語では非常に厳しい設計になっておりプログラムの記述コスト\footnote{プログラム記述する際に必要な時間,お金,人材といったリソースのこと.}と引き換えに安全性を担保している言語があります.また,設計をある程度ゆるくしたり,何回も行っている処理を省略するといった最適化を行うことで実行速度を確保している言語も存在します.さらには,言語の設計によっては同じ機能を実装する場合でも単純な記述量で差---つまりは「その機能を実装するのにどのような方法を取ればいいのか」ということによる記述量の差が生まれる場合もあります.こういった理由でそれぞれの言語には「何をするのに適しているのか」といった向き不向きが生まれます.
\\
\\
また,「ライブラリ」も大きな要因になっています.たとえばアプリケーションを開発する場合を考えてみましょう.この際,スマートフォンの機能にアクセスするには複雑な手続きが必要になります.インターネットに接続するだけでもさまざまな認証をこなし,（コンピュータにとっては）長時間の通信を維持しなければなりません.しかしこういった手続きを予め用意してくれたライブラリがあるとどうでしょうか.最悪の場合,一行で済んでしまうかもしれません.さらに,インターネットに接続する際に特別な操作をしたい場合もあるかもしれません.こうなった場合は既存の機能を一部改変できるようになっていればかなり楽ですよね.これが行えるのが\terlogy{Java}や\terlogy{Swift}といった\teremp[オブジェクト指向\footnote{オブジェクト指向については後述.プログラミング言語設計の考え方の1つです.}]型の言語で,現にアプリケーション開発では頻繁に使われています.こういったライブラリとの兼ね合いやライブラリそのものがプログラミング言語が衰退し,表舞台から姿を消すことを妨げているのです.
\\
\\
言語学が学問として成立していることからもプログラミング言語も言語である以上,その設計にも多様な考え方があり,文法ルールの違いだけでなくこういった考え方の違いがプログラミング言語の向き不向きを決定しているのです.そして,そういった特徴がプログラミングの多様性となっています.

\section{プログラムの実行}
プログラミング言語によって記述されたプログラムはそれ単体では動作しません.当然,「実行する」というステップを踏むことになります.実行の方式は大きく分けて\teremp[インタプリタ方式][Interpreter Method]と\teremp[コンパイル方式][Compile Method]の2つが存在します.その2方式とも最初の流れは同じになりますのでそれを下に示します.

\begin{enumerate}
  \item 字句解析\\
        プログラムを読み取り,記号や単語などを読み取ります.自然言語では,「品詞分解」に当たります.
  \item 構文解析\\
        字句解析されたプログラムを元に\teremp[抽象決定木][AST;Abstract Syntax Tree]などのデータ構造を構築して,構文を解釈します.
\end{enumerate}

次は,その後どのように処理されるかにおいて2つに違いがあるのでそれぞれについて説明します.

\subsection{インタプリタ方式}
インタプリタ方式はソースコードから行ごとまたは文ごとに直接実行する方式です.字句解析,構文解析,ASTを元に実行\footnote{この際,直接実行する他に低水準な中間表現や機械語に変換し効率化するものも存在する},というステップ毎行行います.プラットフォームに依存せずこういった実行作業を担う「解釈機」さえあればどこでも実行が可能です.また,1行ずつ実行する性質上,プログラミング言語は\teremp[REPL][Read-Eval-Print Loop]\footnote{コンソールなどに1行ずつコード入力し対話式にプログラムを進めていく方式}などの対話的な機能を提供できます.
\\
\\
ただ,毎行実行されるため,プログラム全体の動作が遅くなる可能性があります.また,解釈機が環境に存在する必要があり,非開発者の場合でもその言語の解釈機をインストールしなければなりません.インタプリタ方式のプログラミング言語の例として\texttt{Python, Ruby, Perl, PHP, JavaScript, Lua, R, bash, sh, zsh, BASIC, Lisp}が挙げられます.全体として手頃で緩めの設計であることが多いです.

\subsection{コンパイル方式}
コンパイル方式とはその名の通り,コンパイルが必要になります.コンパイルはプログラム全体を字句解析,構文解析した後に次のような処理を行う方式です.

\begin{enumerate}
  \item 意味解析\\
        ACTを解析し,スコープや型のチェックといったプログラムの意味を特定します.
  \item 機械語への変換\\
        プログラムの意味を翻訳し,より低水準な機械語に変換します.
  \item リンキング\footnote{リンキングはコンパイル作業に含まない場合があります.}\\
        変換された機械語をソースコード間で結合処理を行います.
  \item 実行\footnote{実行はコンパイル作業に含まない場合があります.}
\end{enumerate}

ここまで見ると,インタプリタ方式と変わらないように見えますが,最大の特徴はソースコードを一括で処理し,機械語に変換してしまうということです.インタプリタ言語とは違い,1行ずつ実行しないので機械語での保存---つまりソフトウェアとしての保存---が容易であり実行のみで考えれば環境に依存せず,実行速度も速い場合が多いです.ただし,全体をコンパイルする必要があるため開発速度はインタプリタ方式に劣ります.コンパイル方式の言語として\texttt{C/C++, Java, C\#, Swift, Objective-C, Rust, Go, Kotlin, Fortran, COBOL, Assembly}が挙げられます.全体を意味解析してから実行できるので安全性や事前チェックが厳しい言語が多く,アプリやシステムといったものに使われる事が多いです.

\Chapter{データ型と値}
\section{データ型とは}
プログラミング言語には「型」といった概念が存在します.前章でプログラミング言語は情報を情報たらしめるルールであることを確認しました.しかしどんな情報でも等しく扱えるわけではありません.たとえば,ここに「8」が存在するとします.「これに『10』を加えてください」と言われたはあなたはなんと答えるでしょうか.多くの方はおそらく「18」と答えたことでしょう.しかし,「810」と答える方も少なからずいるのではないでしょうか.そう答えなかったとしても「810」という答えには納得できると思います.これは与えられたもの---ここではあえて「数値」という呼称は避けますが---が数字なのか文字なのかという認識の違いです.人間は柔軟に考えることができますが,すべてが数値化されたコンピュータではこの違いは大変な違いです.前者の場合,「8」は$1000_{(2)}$\footnote{2進法で8.}という数字であり,後者の場合は\terlogy{U+0038}\footnote{Unicode表記で"8".}という文字になるのです.もしあなたが数字としての「8」と文字としての「10」を足してくださいと言われたら困るでしょう.
\\
\\
機械がこれを間違えないように「型」を設定し,情報---つまりは「値」---の形式を決定しているのです.言語によってさまざまで整数と浮動小数点数\footnote{いわゆる少数のこと}を別の型に設定している言語や,同じ型として扱う言語も存在します.こういった型の設定方法や型を確認する手順などを「型システム」といい,型システムの設計の違いも言語の特徴の1つです.

\section{プリミティブ型と参照型}
型において非常に難解で重要な概念が\teremp[プリミティブ型（基本データ型）]と\teremp[参照型]の違いです.型には大きく分けてこの2つがあると思って構いません.

\subsection{プリミティブ型}
プリミティブ型は基本データ型とも呼ばれ,もっとも基本的な型でプログラミング言語の仕様に組み込まれる形で標準的に用意されているものです.言語によってどのようなものが用意されているかはまちまちですが\terlogy{Java}では以下のようなものがあたります.

\begin{center}
  \begin{tabular}{|c|c|c|}
    \hline
    \textbf{型}      & \textbf{ビット数} & \textbf{説明}                                \\
    \hline
    \texttt{byte}    & 8                 & 8ビットの符号付き整数値                      \\
    \hline
    \texttt{short}   & 16                & 16ビットの符号付き整数値                     \\
    \hline
    \texttt{int}     & 32                & 32ビットの符号付き整数値                     \\
    \hline
    \texttt{long}    & 64                & 64ビットの符号付き整数値                     \\
    \hline
    \texttt{float}   & 32                & 単精度浮動小数点数                           \\
    \hline
    \texttt{double}  & 64                & 倍精度浮動小数点数                           \\
    \hline
    \texttt{boolean} & -                 & 真偽値 (\texttt{true} または \texttt{false}) \\
    \hline
    \texttt{char}    & 16                & Unicode文字                                  \\
    \hline
  \end{tabular}
\end{center}

\subsection{参照型}
参照型はプリミティブ型の集合である複合データ型\footnote{複数のプリミティブ型とそれらを保存したり扱いやすくしたりする構造の2つからなるデータ型.}の一種で,値そのものではなく値の\teremp[ポインタ（参照）]を保存する型のことです.たとえば,家の中に人がいるとします.家には1人の人しか入れません.プリミティブ型ではこの場合人そのものをデータに保存します.もしデータがコピーされることがあれば家の中の人がコピーされ,コピーしてできた人は他の家に移り住みます.対して,参照型は家の住所だけをデータに保存します.これをコピーしても同じ住所を保存したデータがもう1つ複製されただけでその2つのデータは同じ住所を指します.人はコピーされず1人のままです.プリミティブ型以外のほとんどの型が参照型でクラスなども参照型になります.
\\
以下は\terlogy{Python}による2つの型の違いを説明したコードです.\terlogy{Python}がわからない方は読み飛ばして構いません.
\begin{zenn}
  \begin{lstlisting}[language= mypy]
# プリミティブ型の例
num1 = 10
num2 = num1

print("num1:", num1)  # 出力: num1: 10
print("num2:", num2)  # 出力: num2: 10

num1 = 20

print("num1:", num1)  # 出力: num1: 20
print("num2:", num2)  # 出力: num2: 10 (num2は変更されていない)

# 参照型の例
list1 = [1, 2, 3]
list2 = list1

print("list1:", list1)  # 出力: list1: [1, 2, 3]
print("list2:", list2)  # 出力: list2: [1, 2, 3]

list1.append(4)

print("list1:", list1)  # 出力: list1: [1, 2, 3, 4] (list1が変更された)
print("list2:", list2)  # 出力: list2: [1, 2, 3, 4] (list2も同じ変更が反映されている)
\end{lstlisting}
\end{zenn}
上の例では変数の代入で例を示していますが,関数やメソッドに引数を渡すときも上のコードのように関数内での再代入や値の編集を行うと,関数外の変数違いが出てくることになります.

\section{変数とは}
変数とは「データ型」「識別子（変数名）」「値（情報/データ）」の3要素を持つ,データの記憶域のことを指します.「変数」という名前は多くの方が数学分野で聞いたことがあるでしょう.数学では未知数を$x$や$a$といった文字で置くことで方程式を構成します.プログラミングでの変数も概ね同じように識別子=変数名という名前で値を管理します.ただ1つ違うのは値の型が数学とは違って数字以外の可能性があるということです.なので,変数は必ずその保存するデータ型を明確にしなければなりません.\footnote{明確にするというのは明記するということではない.一部の言語ではデータ型の記載を省略できる.}

\section{変数のライフサイクル}
変数はどのように生まれてどのように破棄されていくのでしょうか.突然,突拍子のないことを言い出したと思うかもしれませんがこれは非常に大事な問題です.コンピュータの記憶領域---データの保管場所は有限です.また同時に,必要な変数が最初から用意されているわけでもありません.変数が生まれて,使用され,破棄されていること,そのことこそがライフサイクルというのです.
\\\\
変数のライフサイクルは一般的に\teremp[確保（宣言）],\teremp[代入], \teremp[参照], \teremp[解放]の4ステップです.この,確保から解放までの期間をライフタイムとも呼びます.

\subsection{確保（宣言）}
プログラム内で変数名,データ型\footnote{データ型は言語と場合によって省略可.}を明記し,変数を定義することを\teremp[宣言],その命令を行い,コンピュータの記憶領域内のにデータを保存するための領域を予約するのを\teremp[確保]といいます.変数に対するすべての操作に先んじて行われる必要があります.\terlogy{Python}では宣言のみを行うということができないので,代わりに\terlogy{Java}の宣言方法を以下に示します.

\begin{zenn}
  \begin{lstlisting}[language= myjava]
int variable; // [データ型] [変数名];
\end{lstlisting}
\end{zenn}

\subsection{代入}
宣言した変数に「値」を紐づけることを代入といいます.概ね数学と同じ意味ですが,プログラミング言語には参照型が存在するので値そのものが代入されているわけではないことに注意してください.以下に\terlogy{Python}での代入方法を以下に示します.

\begin{zenn}
  \begin{lstlisting}[language= mypy]
variable = 810 # [変数名] = [代入される値]
\end{lstlisting}
\end{zenn}

また宣言後,最初に行われる代入を\teremp[初期化][initialize]といいます.宣言しただけの変数は非常に危険で意図しない動作の原因になる場合がある\footnote{変数自体は宣言されているため,言語によっては初期化してない状態の変数を参照することを未然に防ぐことができない.}ので最初に初期化するのが重要です.

\begin{column}{\texttt{Python}における代入と初期化}
\terlogy{Python}では宣言時に初期化を行う必要があります.つまり,宣言と初期化は同じものと考えて構いません.加えて,宣言（=初期化）と代入が見かけ上,同じコードになってしまいます.上の例では\terlogy{variable}という変数に\terlogy{810}という値を代入をしていますが,これは状況によっては\terlogy{variable}を宣言しているという意味になります.もし,\terlogy{variable}がそれ以前のコードで宣言されている場合は代入,そうでない場合は宣言となります.
\end{column}

\subsection{参照}
変数にアクセスしその値を使用することを\teremp[参照]といいます.プリミティブ型の場合は単純に値を使いますが,参照型の場合は参照にアクセスします.ほとんどの言語において変数名を記載するだけで使うことができます.
\begin{column}{変数の展開}
  変数を使用するという言い方だけでは複雑なコードを理解するときに非常に苦労する可能性があります.そこで「変数を展開する」というイメージを持つことが大切です.より深い変数から順にその値で置き換えるということです.次の例を見てみましょう.1行目は展開を繰り返すことで4行目と同じ意味になります.
  \begin{zenn}
    \begin{lstlisting}[language= mypy]
ans = add(add(a, b), 1) # a=5 b=7とし,addは2つの引数を加える関数とする.
ans = add(add(5, 7), 1) # 1回目の展開
ans = add(12, 1)        # 2回目の展開
ans = 13                # 3回目の展開
\end{lstlisting}
  \end{zenn}
\end{column}

\subsection{解放}
値を記憶領域から削除し,参照できない状態になることを\teremp[解放]といいます.解放後はその値へのアクセス全般が担保されない状態となります.似たような概念としてスコープというものがありますがそれとの違いは次節で説明します.

\section{変数のスコープ}
変数にアクセスできる範囲を\teremp[スコープ][scope]と言います.これは変数への意図しないアクセスを防ぐために設けられているもので,よく使用されるものは\teremp[グローバル（大域）スコープ]と\teremp[ローカル（局所）スコープ]に分けられます.グローバルスコープはアプリケーション全体やクラス全体から参照できるというもので「定数」や「メンバ変数」がこれに当たり,その変数をグローバルスコープで定義するのは適切なのかという吟味が必要です.対してローカルスコープはブロックごとに細かく設定されているものです.
\\
\\
ローカルスコープにはさらに\teremp[関数スコープ]と\teremp[ブロックスコープ]の2種類のスコープが存在します.関数スコープは関数やメソッド内で定義された変数は関数外では参照できないというルールです.ブロックスコープはブロックを構成する区切り文字によって囲まれた内部（これを\teremp[ブロック]という.）でのみ参照できるというルールで,多くのプログラミング言語では\terlogy{\{\}}がこの区切り文字となっています.入れ子構造になっている場合は「より深い」ブロック内は基底ブロック内に含まれているということになるため,参照が可能です.
\\
ここで,次の\terlogy{Java}のコードを見てみましょう.\footnote{ここで\terlogy{Java}のコードを引用するのは\terlogy{Python}にブロックスコープが存在しないためであり,これは稀なことです.}

\begin{zenn}
  \begin{lstlisting}[language=myjava]
// グローバルスコープをもつ変数
String variableGlobal = "Hello,World!"

// 関数を定義する
void myFunc(String arg) {
  String variableFunc = "Hello,Function!";

  System.out.println(arg);            // argは関数スコープを持ち,参照可
  System.out.println(variableFunc);   // <後述>
  System.out.println(variableGlobal); // グローバルスコープなので参照可
}

// 関数外では
System.out.println(arg);            // !Error
System.out.println(variableFunc);   // !Error
System.out.println(variableGlobal); // グローバルスコープなので参照可
\end{lstlisting}
\end{zenn}
一般的に,引数はその関数内で関数スコープのみを持ち,関数内のどこでも参照できます.上の例であれば\terlogy{arg}のことです.対して\terlogy{variableFunc}は関数の中で定義されている変数なので関数スコープを持ちます.また,\terlogy{\{\}}に囲まれているのでブロックの内部で定義されていることになるのでブロックスコープも持ちます.9行目は定義ブロックと同じブロック内なので参照が可能です.

\begin{column}{\texttt{Java}における関数スコープ}
  \terlogy{Java}をはじめとした「『関数の構成』にも『ブロックの構成』にも\terlogy{\{\}}といった同じ区切り文字を使用する言語」は関数を形作っているブロックによるブロックスコープと関数スコープが同じ役割を果たしているので関数ブロックもブロックスコープに含めて考えることができます.
\end{column}

\terlogy{Java}は\terlogy{\{\}}単体でもブロックをブロックスコープについてのコードを見てください.

\begin{zenn}
  \begin{lstlisting}[language=myjava]
{
  // なにかの関数内
  String variableA = "A";
  {
      String variableB = "B";
      {
          String variableB = "C";
          // すべて参照可
          // ○variableA ○variableB ○variableC
      }
      // ○variableA ○variableB
  }
  {
      // <ポイント>
      // ○variableA
  }
  // ○variableA
}
\end{lstlisting}
\end{zenn}

上のコードではさまざまなブロック階層で変数を定義し,その位置で参照可能な変数だけを\terlogy{○\[変数名\]}という形で表現しています.一番階層の高い（=浅い）ブロックで定義された\terlogy{variableA}はより深いブロックとそれより深いブロックでも参照ができます.対して\terlogy{variableB}ではより深いブロックでは参照ができてますが,浅いブロックでは参照できません.14行目の\terlogy{<ポイント>}が書かれたブロックは\terlogy{variableB}の定義ブロックと同じインデントレベル\footnote{ブロックの入れ子構造がわかりやすいようにインデント（=タブやスペース2文字,4文字で字下げを行うこと.）をした際のインデント数のこと.入れ子が1つ増えるとインデントレベルは1だけ上がる.}ですが,\terlogy{variableB}の定義ブロックの入れ子または同じブロックにはなっていないので\terlogy{variableB}を参照することができません.

\subsection{\texttt{Python}におけるブロックスコープ}
\terlogy{Python}に限った話をしますと,\terlogy{Python}はブロックスコープを持ちません.なので,以下のようなコードが成り立ちます.

\begin{zenn}
  \begin{lstlisting}[language=mypy]
def division(a, b):
if b == 0:
  ans = "divided by zero"
else:
  ans = a / b
print(ans)
\end{lstlisting}
\end{zenn}

\terlogy{Python}の場合,\terlogy{:（コロン）}がブロックを形成します.\terlogy{ans}が\terlogy{if}あるいは\terlogy{else}内で定義されていますが,その外でも\terlogy{print(ans)}のように使用できます.なお,\terlogy{ans}の型が揃ってなくてもかまわないのは\terlogy{Python}が「動的型付け言語」だからです.詳しくは次節で解説します.

ですが,「1.グローバルスコープ」「2.初期化と代入が同じ」「3.関数スコープ」というのが重なって不思議な挙動となります.


\begin{zenn}
  \begin{lstlisting}[language=mypy]
x = 10
def func():
  print(x)
func()
# 出力結果: 10
\end{lstlisting}
\end{zenn}
これを実行してみると単に「10」と出力されます.これは\terlogy{x}がグローバルスコープなので関数内でも外の値を参照できるからです.ではこれはどうでしょう.

\begin{zenn}
  \begin{lstlisting}[language=mypy]
x = 10
def func():
  print(x) # !Error
  x = 20
func()
\end{lstlisting}
\end{zenn}

さきほどから1行だけ加え,表示後に値を「再代入」してみました.これは\terlogy{エラー}になります.関数内で\terlogy{x = 20}といった参照ではない動きをした場合,もしその識別子が登場してないなら,解釈機はこれを\teremp[初期化/宣言]と解釈します.すると\terlogy{print(x)}は初期化前の変数を参照したとしてエラーが起こるわけです.いくら解釈機が1行ずつ読んでいくとしても最終行の\terlogy{func()}の時点では関数定義をすべて読み終えているので関数内で使用する可能性のある変数などはどんなブロックにいてもすでにASTに組み込まれているのです.
\\\\
ここで,\terlogy{print(x)}を削除してあげるとエラーは発生しませんが,\terlogy{func()}関数内の\terlogy{x}とグローバルな\terlogy{x}は同じ識別子をもった別の変数として振る舞います.

\begin{zenn}
  \begin{lstlisting}[language=mypy]
x = 10
def func():
  x = 20
  print(x)
func()
print(x)

# 出力結果: 20 10
\end{lstlisting}
\end{zenn}

\section{型付け}
型システムについて変数を束縛あるいは制限することを\teremp[型付け][typing]といいます.この節では型付けについての様々な視点からの分類を学びます.

\subsection{静的 vs 動的}
言語は型付与において\teremp[静的型付け][tatic typing]と\teremp[動的型付け][dynamic typing]の2つに分類できます.前者はコンパイル時に型の\teremp[検査][check]を行う方式で,宣言時に決めた型を途中で変更することはできません.安全性が高いですが,柔軟な記述ができません.対して,後者は実行しながらその都度検査を行いますので,同じ変数でも動的に型を変える事ができます.柔軟な記述が可能で変数の数を減らせますが,意図しない動作をする場合は危険になります.下のコードは静的型付け言語である\terlogy{Java}と動的型付け言語である\terlogy{Python}による違いを示しています.

\begin{zennwt}{Javaの例}
  \begin{lstlisting}[language=myjava]
String strNumber = "810";
strNumber = 0; // !Error
\end{lstlisting}
\end{zennwt}

\begin{zennwt}{Pythonの例}
  \begin{lstlisting}[language=mypy]
strNumber = "810";
strNumber = 0; #  OK
\end{lstlisting}
\end{zennwt}

\terlogy{Java}では文字列に数字を代入しようとするとエラーとなりますが,\terlogy{Python}は途中で型を再付与して文字列の変数を数字の変数にしています.

\subsection{強い vs 弱い}
付与された型による規約の強さでプログラミング言語は\teremp[強い型付け][strong typing]と\teremp[弱い型付け][weak typing]の2つに分類できます.この2つの違いは,変数の結合や代入をはじめとした使用についてどれほど型で制限するということです.具体的には前者は「暗黙的」な\teremp[キャスト=型変換]ができませんが後者はできます.次に例を示します.なお,\terlogy{Python}は強い型付け言語で\terlogy{PHP}は弱い型付け言語です.

\begin{zennwt}{Pythonの例}
  \begin{lstlisting}[language=mypy]
number = 10
text = "20"
print(text + number) #  !Error
\end{lstlisting}
\end{zennwt}


\begin{zennwt}{PHPの例}
  \begin{lstlisting}[language=myphp]
<?php
$number = 10;
$text = "20";
echo $text + $number; // 出力結果: 30
?>
\end{lstlisting}
\end{zennwt}

\terlogy{Python}は強い型付け言語なので数字と文字列を結合することはできません.対して,\terlogy{PHP}は弱い型付け言語なので数字と文字列を結合することができます.

\begin{column}{強い型付け言語でも文字列と数字の結合でエラーが出ない}
  実は文字列と数字の結合でエラーが出る言語はそれほど多くはありません.例えば\terlogy{Java}では以下のようになります.
  \begin{zennwt}{Javaの例}
    \begin{lstlisting}[language=myjava]
int number = 10;
String text = "20";
System.out.println(number + text); // 出力結果: 1020
\end{lstlisting}
  \end{zennwt}
  \terlogy{Java}は\terlogy{+}演算子に文字列と結合するという機能も備えてあり,文字列ではない変数も結合することができます.ただ両方とも文字列になります.このような機能を搭載した言語が多く,文字列と数字の結合でエラーがでる言語が多いというわけではありません.
  \\\\
  ここからは発展事項ですが,\terlogy{Java}では「自分が文字列と結合したときにどのように文字に変わるか」ということをクラスに定義することができます.

  \begin{zennwt}{Javaの例}
    \begin{lstlisting}[language=myjava]
public class Person {
  private String name;
  private int age;

  public Person(String name, int age) {
    this.name = name;
    this.age = age;
  }

  @Override
  public String toString() {
    return "Person{name='" + name + "', age=" + age + "}";
  }
}

Person person = new Person("Alice", 25);
System.out.println("情報：" + person); // 出力結果: 情報：Person{name='Alice', age=25}
\end{lstlisting}
  \end{zennwt}

  クラスは複雑な構造をしているので文字列どのように結合した際の表示が暗黙的にわからず,（おそらく）クラスの参照IDだけを出力してしまうのでユーザが正しい表示を定義できるようになっています.

\end{column}


\begin{column}{だれも強い/弱いを意識してない}
  上の例で\terlogy{PHP}が急に出てきて驚いた方も多いと思います.現在使われている言語のうち大多数が強い型付け言語なので例が作りにくいのです.もちろん,\terlogy{JavaScript}\footnote{\terlogy{JavaScript}は文字列と数字を結合すると文字列となってしまうので上の例では使用しなかった.}のような弱い型付けの言語が使われていることがありますが,強い/弱いの違いを意識する場面が非常に少ないのであまり意識しなくていいと思います.
\end{column}

\subsection{型推論}
変数の宣言時あるいは型の再付与時,その型を明記しなくてもコンパイラや解釈機が自動で型の決定を行う機能を\teremp[型推論][type inference]という.型推論の機能がない言語は,型を\teremp[明示]しなければならない.ただし,型推論を行う言語でもコンパイラが型を判別するのが困難な場合---たとえば,その値に対応できる型が複数ある場合---は明記する必要がある.

\subsection{名前的 vs 構造的 vs ダッグ・タイピング}
型を判別する際,名前で判別する型システムを\teremp[名前的型システム][nominal type system],その構造で判別する型システムを\teremp[構造的型システム][structural type system]といいます.型を判別するというのは型が等価であるか判別するということです.例えば\terlogy{A}という型の変数\terlogy{a}を\terlogy{B}という型で宣言した\terlogy{b}の初期化に使うとき,数字なら数字と同じように\terlogy{A}と\terlogy{B}が等価にならこの初期化は成功しますが,等価でないなら成功しません.この「等価」の判断に,名前的型システムならその型の名前の一致を,構造型システムなら構造の一致（例えばその関数のフィールドや定義されたメソッドの名前や設定=シグネチャ\footnote{メソッドの設定.戻り値,引数のデータ型やメソッドの名前.}が一致しているか）を判断基準としてしようするということです.変数の代入でなくとも,すべての型検査が必要な場面にこの判断は行われます.
\\
\\
そのどちらでもない手法に\teremp[ダック・タイピング][duck typing]が存在します.これは名前でも構造でもなく,そもそも型チェックを行いません.ただ,「同じような振る舞いをするなら等価な型とみなす」という基準をもつ型付け手法です.これは構造的型付けと非常によく似ていますが違います.ダック・タイピングの例を見てみましょう.

\begin{zenn}
  \begin{lstlisting}[language=mypy]
def add(a, b):
    return a + b

print(add(1, 2))                # 出力結果: 3
print(add("Hello, ", "World!")) # 出力結果: "Hello, World!"

\end{lstlisting}
\end{zenn}

\terlogy{Python}は文字列でも数字も\terlogy{+}で足すことができます.もちろん意味は違って数字なら足し算ですが,文字なら結合です.しかしどちらも演算可能ではあります.ダック・タイピングでは上のように明示されてなければ引数の型をも型検査に通しません.ですが両方とも演算可能なのでゆるされます.構造的型付けではどちらも足すことはできますが,そもそも型の構造が一致してないのでこのような書き方はできません.ダック・タイピングはこのように柔軟な記述ができるという利益がある一方,バグの温床にもなりやすいです.

\subsection{各言語の片付け}
以下に各言語の型付けの性質をまとめました.ただ,そもそもこのような特徴を気にしない人が多く,言語によっては言い切れないものもありますので参考程度に御覧ください.（著者注釈：このひょうはChatGPTに出力させたもので間違いがあります.現在まだ裏を取っている途中です.）
\begin{center}
  \begin{tabular}{|l|c|c|c|c|}
    \hline
    \textbf{言語名} & \textbf{動的/静的} & \textbf{強い/弱い} & \textbf{型推論} & \textbf{名前的/構造的/ダック} \\
    \hline
    Python          & {\color{red}動的}  & {\color{red}強い}  & {○}             & ダック                        \\
    JavaScript      & {\color{red}動的}  & {\color{blue}弱い} & {○}             & ダック                        \\
    Java            & {\color{blue}静的} & {\color{red}強い}  & {○}             & 名前                          \\
    C               & {\color{blue}静的} & {\color{blue}弱い} & {-}             & 名前                          \\
    C++             & {\color{blue}静的} & {\color{red}強い}  & {○}             & 名前                          \\
    C\#             & {\color{blue}静的} & {\color{red}強い}  & {○}             & 名前                          \\
    Ruby            & {\color{red}動的}  & {\color{red}強い}  & {○}             & ダック                        \\
    Swift           & {\color{blue}静的} & {\color{red}強い}  & {○}             & 名前                          \\
    Go              & {\color{blue}静的} & {\color{red}強い}  & {○}             & 両方                          \\
    PHP             & {\color{red}動的}  & {\color{blue}弱い} & {○}             & ダック                        \\
    Rust            & {\color{blue}静的} & {\color{red}強い}  & {○}             & 名前                          \\
    TypeScript      & {\color{blue}静的} & {\color{red}強い}  & {○}             & 構造                          \\
    Kotlin          & {\color{blue}静的} & {\color{red}強い}  & {○}             & 名前                          \\
    MATLAB          & {\color{red}動的}  & {\color{blue}弱い} & {-}             & ダック                        \\
    Perl            & {\color{red}動的}  & {\color{blue}弱い} & {-}             & ダック                        \\
    R               & {\color{red}動的}  & {\color{blue}弱い} & {○}             & 名前                          \\
    Lua             & {\color{red}動的}  & {\color{blue}弱い} & {○}             & 名前                          \\
    Haskell         & {\color{blue}静的} & {\color{red}強い}  & {○}             & 名前                          \\
    Scala           & {\color{blue}静的} & {\color{red}強い}  & {○}             & 両方                          \\
    Shell scripting & {\color{red}動的}  & {\color{blue}弱い} & {-}             & 名前                          \\
    Visual Basic    & {\color{blue}静的} & {\color{blue}弱い} & {○}             & 名前                          \\
    Objective-C     & {\color{blue}静的} & {\color{red}強い}  & {-}             & 名前                          \\
    Fortran         & {\color{blue}静的} & {\color{blue}弱い} & {-}             & 名前                          \\
    Prolog          & {\color{red}動的}  & {\color{red}強い}  & {-}             & 名前                          \\
    COBOL           & {\color{blue}静的} & {\color{blue}弱い} & {-}             & 名前                          \\
    F\#             & {\color{blue}静的} & {\color{red}強い}  & {○}             & 名前                          \\
    \hline
  \end{tabular}
\end{center}

\section{定数と\texttt{Null}とリテラルと}
ソースコード上に直接書いた値を\teremp[リテラル][literal]といいます.ここで注意しなければならないのは,リテラルは値を代入した変数のことを指しているのではなく,ソースコードに直接書いた部分だけを指すということです.以下に\terlogy{Python}による例を示します.

\begin{zenn}
  \begin{lstlisting}[language=mypy]
number1 = 810           # リテラル
text1 = "Hello, World!" # リテラル
number2 = number1       # リテラルでない
text2 = text1           # リテラルでない
\end{lstlisting}
\end{zenn}

それに対して,初期化のみで代入ができない変数を特別に\teremp[定数][constant]といいます.本質的には変数と変わらないですが,変数と定数は比較できる関係で,一般的に変数といった場合は定数は除くことが多いです.型システムによって再代入が禁止されたり定数を定義する文法が用意されている言語が多いですが,\terlogy{Python}のように定数が存在しない言語もあります.以下に\terlogy{Java}の例を示します.

\begin{zenn}
  \begin{lstlisting}[language=myjava]
final int MY_AGE = 18;
public static final double PI = 3.14159265;
\end{lstlisting}
\end{zenn}

\terlogy{Java}は1行目のように\terlogy{final}をつけるだけで基本的には定数となります.ただ,定数はいつでも使えるようしたいことが多いため,二行目の書き方が使われることが多いです.詳しいことはオブジェクト指向の章で述べます.
\\
\\
プログラミングでは「値無し」を表すために\teremp[\texttt{Null}=ヌル=ナル][nil=ニル, None=ナン]という値が使われます.言語によって\terlogy{nil}などの別の呼び方になることもありますが,これは「値が存在しない」という値です.数学でいうところの「解なし」にあたります.例えば,$x^2+x+1=0$を満たす実数$x$は存在しないですよね.このようなときに$x$は\terlogy{Null}といえるのです.\terlogy{0}や\terlogy{""}（空文字=文字数0の文字列）は値が存在しているので\terlogy{Null}とはいえません.\terlogy{Null}値はどの型の性質も持たないので読み取ることしかできません.値が存在しないという概念や構文のミスが結果的に\terlogy{Null}に起因してしまう事が多く,初学者は頻繁に出会うことになります.

\begin{column}{ヌル？}
  実は英語の正確な発音では\terlogy{Null}はナルと発音します.しかし日本ではヌルと呼ぶことが一般的になってしまったのでむしろ正しい読み方となってしまいました.
\end{column}

\section{演算}
値を計算したり評価することを\teremp[演算]といい,\teremp[演算子]は演算を表す記号・マーカーのことを指します.プログラミングにおいては単純な四則演算子以外にも様々な演算子が存在します.1つの値だけを用いる\teremp[1項演算子],2つの値だけを用いる\teremp[2項演算子]といった具合に項数もまちまちです.そんな演算子について種類別にまとめます.ただし,以下に示す演算子はプログラミング言語によって異なり,ないものもあることに注意してください.

\subsection{算術演算子}
演算と聞いて想像するようないわゆる「計算」を行う演算子を\teremp[算術演算子]といいます.

\begin{center}
\begin{tabular}{|c|c|}
  \hline
  \textbf{演算子} & \textbf{説明} \\ \hline
  \terlogy{x + y} & 加算 \\ \hline
  \terlogy{x - y} & 減算 \\ \hline
  \terlogy{x * y} & 乗算 \\ \hline
  \terlogy{x / y} & 除算（xをyで割る） \\ \hline
  \terlogy{x \% y} & 剰余（xをyで割った余り） \\ \hline
  \terlogy{x ** y} & べき乗（xのy乗） \\ \hline
  \end{tabular}
\end{center}

特徴としては「×」や「÷」が「*」「/」になっています.また,剰余がプログラミングにおいては大切な役割を果たしていることがあるので,割りと使います.

\subsection{ビット演算子}
コンピュータはビットの演算によって様々な計算を可能にしており,プログラミング言語でもビットの演算についての演算子である\terlogy{ビット演算子}が存在します.使う機会は少なそうですが.
\begin{center}
\begin{tabular}{|c|c|}
  \hline
  \textbf{演算子} & \textbf{名称} \\
  \hline
  \terlogy{x & y} & ビットAND（論理積） \\
  \hline
  \terlogy{x | y} & ビットOR（論理和） \\
  \hline
  \terlogy{x ^ y} & ビットXOR（排他的論理和） \\
  \hline
  \terlogy{~x} & ビットNOT（反転） \\
  \hline
  \terlogy{x << y} & 左シフト（yだけシフト） \\
  \hline
  \terlogy{x >> y} & 右シフト（yだけシフト） \\
  \hline
\end{tabular}
\end{center}



\subsection{代入演算子}
変数に代入を行う演算子を\teremp[代入演算子]といいます.プログラミング言語では算術演算子と組み合わせて代入を行うことが多いため,算術と代入を組み合わせた\teremp[複合代入演算子]が準備されています.
\begin{center}
  \begin{tabular}{|c|c|c|}
  \hline
  \textbf{演算子} & \textbf{名称} & \textbf{書き換え} \\
  \hline
  \terlogy{x = y} & 代入 & --- \\
  \hline
  \terlogy{x += y} & 加算代入 & \terlogy{x = x + y} \\
  \hline
  \terlogy{x -= y} & 減算代入 & \terlogy{x = x - y} \\
  \hline
  \terlogy{x *= y} & 乗算代入 & \terlogy{x = x * y} \\
  \hline
  \terlogy{x /= y} & 除算代入 & \terlogy{x = x / y} \\
  \hline
  \terlogy{x \%= y} & 剰余代入 & \terlogy{x = x \% y} \\
  \hline
  \terlogy{x \&= y} & ビット論理積代入 & \terlogy{x = x \& y} \\
  \hline
  \terlogy{x \|= y} & ビット論理和代入 & \terlogy{x = x \| y} \\
  \hline
  \terlogy{x ^= y} & ビット排他的論理和代入 & \terlogy{x = x ^ y} \\
  \hline
  \terlogy{x <<= y} & 左シフト代入 & \terlogy{x = x << y} \\
  \hline
  \terlogy{x >>= y} & 右シフト代入 & \terlogy{x = x >> y} \\
  \hline
  \end{tabular}
  \end{center}

\terlogy{=}はプログラミングでは代入を表すことに注意が必要です.また,\terlogy{=}は右辺を先に評価あるいは計算します.なので,表の書き換えにあるように右辺と左辺で同一の変数を記述できます.つまり,\terlogy{x}を用いて\terlogy{x}を更新できるということですが,代入演算子を用いることで簡単に記述できます.

また糖衣構文として加算代入と減算代入には$y = 1$のとき,それぞれインクリメントとデクリメントが用意されている言語があります.

\begin{center}
  \begin{tabular}{|c|c|c|}
    \hline
    \textbf{演算子} & \textbf{説明} & \textbf{書き換え} \\ \hline
    \terlogy{x++} & インクリメント & \terlogy{x = x + 1}または\terlogy{x += 1} \\ \hline
    \terlogy{x--} & デクリメント & \terlogy{x = x - 1}または\terlogy{x -= 1} \\ \hline
    \end{tabular}
  \end{center}

\subsection{関係演算子}
\teremp[関係演算子]は複数の値の関係をもとに真偽値=\terlogy{boolean}を演算結果として返します.

\begin{center}
  \begin{tabular}{|c|c|l|}
  \hline
  \textbf{演算子} & \textbf{名称} & \textbf{Trueとなる条件（それ以外はFalse）} \\
  \hline
  \terlogy{x == y} & 等しい & \terlogy{x} と \terlogy{y} が等しい場合にTrue \\
  \terlogy{x != y} & 等しくない & \terlogy{x} と \terlogy{y} が異なる場合にTrue \\
  \terlogy{x > y} & 大なり & \terlogy{x} が \terlogy{y} よりも大きい場合にTrue \\
  \terlogy{x >= y} & 大なりイコール & \terlogy{x} が \terlogy{y} 以上の場合にTrue \\
  \terlogy{x < y} & 小なり & \terlogy{x} が \terlogy{y} よりも小さい場合にTrue \\
  \terlogy{x <= y} & 小なりイコール & \terlogy{x} が \terlogy{y} 以下の場合にTrue \\
  \hline
  \end{tabular}
\end{center}

関係演算子は条件文という言い方をされることもありますが,\terlogy{if文}以外にも単純に変数に真偽値を代入する目的で使いますので本質は違います.ただし,わかりやすさのため本書では関係演算子や真偽値によりいわゆる「条件」を表すまとまりを,\terlogy{条件文}と表記することにします.

\subsection{論理演算子}
複数の真偽値を評価し,真偽値を返す演算子を\teremp[論理演算子]といいます.

\begin{center}
\begin{tabular}{|c|c|l|}
  \hline
  \textbf{演算子} & \textbf{名称} & \textbf{説明} \\
  \hline
  \terlogy{x \&\& y}または\terlogy{x and y} & 論理AND & \terlogy{x}と\terlogy{y}がTrueの場合にTrueを返す \\
  \terlogy{x \|\| y}または\terlogy{x or y} & 論理OR & \terlogy{x}と\terlogy{y}の少なくとも1つがTrueの場合にTrueを返す \\
  \terlogy{!x}または\terlogy{not x} & 論理NOT & 条件を反転（TrueならFalseに,FalseならTrueに） \\
  \hline
\end{tabular}
\end{center}

\terlogy{x}や\terlogy{y}には関係演算子によるいわゆる条件式が置かれることが多いですが,真偽値の変数も置くことができます.

\begin{column}{短絡評価}
  \terlogy{x \&\& y}と\terlogy{x \|\| y}は\terlogy{x}が評価された後に結果が定まらない場合のみ\terlogy{y}を評価します.逆に言えば,\terlogy{x}が評価された時点で結果が---このとき,Trueに決まることはないので---Falseに決まる場合は\terlogy{y}を評価しません.これを\teremp[短絡評価]といい,2つは短絡評価の演算子です.


  \begin{zenn}
    \begin{lstlisting}[language=mypy]
  def x(arg):
    print("xが評価されたよ！")
    return arg
  def y(arg):
    print("yが評価されたよ！")
    return arg

  age = 15
  print(x(age >= 18) and y(age < 20))
  # 出力結果： xが評価されたよ！ False

  age = 21
  print(x(age >= 18) and y(age < 20))
  # 出力結果： xが評価されたよ！ yが評価されたよ！ False
\end{lstlisting}
  \end{zenn}

  上のコードは関係演算子に「副作用」を追加した\terlogy{x}と\terlogy{y}という関数を論理演算子で評価したものです.\terlogy{age}が15と21のときはともに論理演算子自体はFalseを返します.しかし,前者は\terlogy{y}---つまり論理演算子の右辺が評価されていません.左辺の評価結果はFalseと決まったとき,\terlogy{and}は両辺がTrueでなければTrueを返さないのでここで論理演算はFalseに決まります.なので,右辺は評価されないのです.

  これは論理XORが存在しない理由の一つ\footnote{一番の理由は使う機会が想像できないからです.使う場合は\terlogy{x != y}で評価できます.}でもあります.XOR---排他的論理和は,両辺のどちらか一方がTrue,もう一方がFalseでなければならないので短絡評価をすることができません.短絡評価は意外と重要で,2項目---つまり,右辺は左辺が評価されることを担保としている場合が多いからです.
\end{column}

\subsection{条件演算子（三項演算子）}
ある真偽値を評価し,それによって異なる2つの値のどちらかを返す演算子を\teremp[条件演算子]または\teremp[三項演算子]といい,一種の糖衣構文とみなすことができます.C言語系と\terlogy{Python}で二種類の書き方があります.以下ではC言語系として\terlogy{Java}の例を挙げます.

\begin{zennwt}{Javaの例}
\begin{lstlisting}[language=myjava]
// [条件文] ? [trueのときの値] : [falseのときの値]
String s = age >= 18 ? "成年済み" : "未成年";
System.out.println("あなたは" + s + "です.");
\end{lstlisting}
\end{zennwt}

\begin{zennwt}{Pythonの例}
  \begin{lstlisting}[language=mypy]
  # [trueのときの値] if [条件文] else [falseのときの値]
  s = "成年済み" if age >= 18 else "未成年"
  print("あなたは" + s + "です.")
\end{lstlisting}
\end{zennwt}

\begin{column}{\texttt{if文}との違い}
条件演算子は\terlogy{if文}の糖衣構文です.上の例を書き換えてみましょう.

\begin{zennwt}{Pythonの例}
\begin{lstlisting}[language=mypy]
  if age >= 18:
    _s = "成年済み"
  else:
    _s = "未成年"
  s = _s
  print("あなたは" + s + "です.")
\end{lstlisting}
\end{zennwt}

\terlogy{if文}による条件分岐の実行ブロックが値の代入のみで終わる場合に糖衣構文として条件演算子が使えます.ただ,あくまで演算子であり,代入はしなくても,例えば引数にしたりすることもできます.上のように\terlogy{_s}という変数を媒介にしたのはそのためです.

また,一部の言語では\terlogy{if文}そのもので三項演算子のような記述ができます.この場合,正確には\terlogy{if式}が準備されており,それを使っていることになります.\terlogy{if文}と\terlogy{if式}---すなわち文と式の違いは後ほど述べます.
\end{column}



\Chapter{制御構造}
プログラムは一般的に書かれた命令を上から下,そして左から右に順に処理するのが基本ですが,その手続きの順番を変える役割をもつ文法やそのコード自体を\teremp[制御構造][control structures]といいます.制御構文,制御フロー文,構造化文なども同様の意味で使われることがあります.なお,複数の命令の集まりを\teremp[プロシージャ=手続き][procedure]や\teremp[ルーチン][routine]と言います.また,プロシージャの実行の流れを\teremp[フロー]と言います.本章ではこういった制御構造の種類について説明していきます.この章では基本的に\terlogy{Python}を使った例を挙げていますが,言語によって表記上の多少の差があることに留意してください.

\section{ジャンプ・無条件分岐命令}
実行フローを途中で切り上げ,前あるいは後ろの特定の位置からフローを再開する制御構造をジャンプといいます.一番基本的な制御構造ゆえに現代ではほとんど明示的には使われていないあるいは次節の条件分岐命令と同一視されています.ですが,ほとんどの制御構造がジャンプを利用しているので,私達は他の制御構造を通してジャンプを使うことができます.

\begin{column}{悪魔の\texttt{Goto}文}
  かつて,\terlogy{C}をはじめとした言語には\terlogy{Goto文}という構文が存在しました.これはコードにラベルなどの識別子を貼り付け,\terlogy{Goto文}でラベルを指定することでラベルを貼っていた命令に強制的にフローをある程度自由に移すことができました.複雑な処理を比較的簡単に記述できましたが,書いた本人にとって簡単でも読む人にとっては非常にわかりにくく,またロジックの崩壊によって無限ループや意図していないフローを作ることがあったので基本的に使うのは良くないという風潮が広まり,\terlogy{Goto文}は姿を消しました.
  \\\\
  なお,このときにフローや人間の思考がまるでスパゲッティのように絡まっていることからこのようにぐちゃぐちゃと複雑で命令の実行フローとコードの構造がわかりずらいコードを\teremp[スパゲッティ・コード]と呼ぶようになったと言われています.
\end{column}

\section{条件分岐命令}
ある一定の法則に従ってある狭い範囲でのジャンプを行い,プロシージャの実行不実行を選択する命令を\teremp[条件分岐命令][branch instruction]といいます.単に分岐命令とも書きます.本質的にはジャンプと大差はないですが,ジャンプほどの自由度は設けられてないことが多く,どちらかというとプロシージャの取捨選択という意味合いの方が強いです.

\subsection{\texttt{IF}文・\texttt{ELSE}文・\texttt{ELSE-IF}文}

基本的な条件分岐は\teremp[\texttt{IF}文]を使用して記述します.以下の例を見てみましょう.

\begin{zenn}
  \begin{lstlisting}[language=mypy]
# ageという変数が初期化されているものとする.
# if [条件文]:[ブロック]
if age < 18:
  print("あなたは未成年です.")

# ageが18未満なら, 出力結果: あなたは未成年です.
\end{lstlisting}
\end{zenn}


これは\terlogy{age}の値によって\terlogy{print処理}を行うか行わないかを切り替えています.\terlogy{if}には条件が必要になりますが,条件というより\terlogy{boolean}の値を指定しているというほうが正しいです.\terlogy{if}は条件に指定した部分を演算あるいは展開などの実行を行いその結果の値が\terlogy{true}なら指定したブロックを実行し,そうでなければ---つまり\terlogy{false}なら読み飛ばします.大切なのは「\terlogy{boolean}を返す式を指定しなければならない=条件文」のと「ブロックを構成すること」です.
\\\\
また,それ以外の場合の処理を記述できる\teremp[\texttt{ELSE}文]と条件が合わないときに別の条件で別のブロックを追加できる\teremp[\texttt{ELSE-IF}文]もあります.例を見てみましょう.

\begin{zenn}
  \begin{lstlisting}[language=mypy]
# ageという変数が初期化されているものとする.
if age < 18:
  print("あなたは未成年です.")
# elif [条件文]:[ブロック]
elif age < 20:
  print("あなたは成人ですがお酒は飲めません.")
# else:[ブロック]
else:
  print("お酒が飲めます.やったね.")

# age < 18なら,      出力結果: あなたは未成年です.
# 18 ≦ age < 20なら,出力結果: あなたは成人ですがお酒は飲めません.
# 20 ≦ ageなら,     出力結果: お酒が飲めます.やったね.
\end{lstlisting}
\end{zenn}

両構文ともに\terlogy{IF文}と\terlogy{ELSE-IF文}の後ろに付けて連なることでのみ使用できます.\terlogy{IF文}は条件分岐命令の後ろには連なりません.\terlogy{IF文}と\terlogy{ELSE-IF文}は条件が満たされ,ブロックの実行が終了した場合,連なっている制御構造の一番うしろにジャンプします.間に連なっている条件分岐命令をすべて無視します.また,\terlogy{ELSE-IF文}は\terlogy{IF文}同様に評価され条件に応じてブロックを実行するかしないかを決めます.そして,\terlogy{IF文}と\terlogy{ELSE-IF文}は満たされなかった場合,連なっている次の条件分岐命令を評価します.\terlogy{ELSE文}は連なった最後に置き,評価される場合常にブロックを実行します.
\\\\
かなり複雑そうですが,すべてを流れで捉えると簡単です.まず,\terlogy{IF文}の条件文を評価しして,これが偽であれば次の\terlogy{ELSE-IF文}の条件文を評価します.これも同様に偽であれば次の\terlogy{ELSE-IF文}に移ります.どこかの条件文が真となればそのブロックを実行し,後ろの\terlogy{ELSE-IF文}や\terlogy{ELSE文}を読み飛ばします.すべてで偽なら最後の\terlogy{ELSE文}のブロックが実行されます.なお,\terlogy{ELSE-IF文}は何個でも連なることができます.
\\\\
注意すべき点は

\begin{itemize}
  \item ブロックの実行後に一番うしろにジャンプするので間に条件が一致している\terlogy{ELSE-IF文}があっても実行されない.
  \item \terlogy{IF文}は\terlogy{IF文}には連なることができない
\end{itemize}

ということです.前者は上に提示したコードの4行目からわかります.たとえば\terlogy{age}が\terlogy{5}の場合,\terlogy{IF文}に当てはまりますが,\terlogy{ELSE-IF文}の条件にも当てはまってるように見えます.しかし実行されるのは3行目のみです.3行目でブロックが終わったときにすでにすべての連なった条件分岐命令が読み飛ばされるので,このコードでは10行目にジャンプします.後者については以下のコードを見てみましょう.

\begin{zenn}
  \begin{lstlisting}[language=mypy]
# ageという変数が初期化されているものとする.
if age < 18:
  print("あなたは未成年です.")
if age < 20:
  print("あなたはお酒は飲めません.")

# age < 18なら,      出力結果: あなたは未成年です.あなたはお酒は飲めません.
# 18 ≦ age < 20なら,出力結果: あなたはお酒は飲めません.
\end{lstlisting}
\end{zenn}

実行結果が少し変わったのがわかりましたか？\terlogy{IF文}と\terlogy{IF文}は連ならないので3行目の実行後,4行目にジャンプします.そこは別の\terlogy{IF文}なので再び評価が行われます.たとえば\terlogy{age}が\terlogy{5}の場合,両方の\terlogy{IF文}に当てはまるので2回ブロックが実行されるのです.

\subsection{\texttt{SWITCH}文}
大量の条件分岐をすべて\terlogy{IF文}などで記述するのは大変です.そんなとき,値の同等評価---つまりは\terlogy{==}演算子---だけであれば\teremp[\texttt{SWITCH}文]を使用することができます.なお,\terlogy{Python}には\terlogy{SWITCH文}はないので\terlogy{Java}を用いて例を挙げます.

\begin{zenn}
  \begin{lstlisting}[language=myjava]
// switch ([評価対象]) {
//   case [値1]:
//     [評価対象 == 値1のときの処理]
//     break;
//   case [値2]:
//     [評価対象 == 値2のときの処理]
//     break;
//   default:
//     [どのcaseにも当てはまらないときの処理]
//     break;
// }

String name = "";
switch (code) {
  case "JP": name = "日本"; break;
  case "KR": name = "韓国"; break;
  case "CN": name = "中国"; break;
  case "US": name = "アメリカ"; break;
  default: name = "一致する国は見つかりませんでした.";
}
\end{lstlisting}
\end{zenn}

上のコードでは国コード\terlogy{code}をもとにそれを国名に変えて\terlogy{name}に代入しています.\terlogy{SWITCH文}は大小評価ができない\footnote{大小評価ができる\terlogy{SWITCH文}を提供している言語も存在します.}かわりに羅列して記述することに優れています.

ただ,注意すべき点があります.それは\terlogy{case}はブロックを構成せず,処理終了後に\terlogy{SWITCH文}の外へジャンプする命令は備えてないことです.前者については多くの言語でブロックを構成する\terlogy{\{\}}が使われていないことによって明らかです.後者については\terlogy{break;}がそれを担っています.\terlogy{break文}は後ほど説明する制御構造の一つで\terlogy{SWITCH文}から抜ける役割をしています.


なので,\terlogy{SWITCH文}では\terlogy{break文}を書かないという選択もできます.次の例を見てください.
\\\\

\begin{zenn}
  \begin{lstlisting}[language=myjava]
switch (dayOfWeek) {
  case 1:
    System.out.println("週初めで且つ");
  case 2:
  case 3:
  case 4:
  case 5:
    System.out.println("平日です");
    break;
  case 6:
  case 7:
    System.out.println("週末です");
    break;
  default:
    System.out.println("無効な日付です");
    break;
}
\end{lstlisting}
\end{zenn}

上の例では\terlogy{dayOfWeek}が2〜5の場合は「平日です」と出力され,6,7のときは「週末です」,1のときは「週始めで且つ平日です」と出力されます.1〜4,6の\terlogy{case}に入った場合,\terlogy{break文}がないのでその次の\terlogy{case}を---条件を満たしてなくても---実行します.それが繰り返し行われることで間の\terlogy{case}の処理を実行しながら最終的に,\terlogy{break文}もしくは最下部に到達し実行が終了します.

\section{ループ命令}
特定の条件下で繰り返し処理を実行させることを\teremp[ループ]といいます.ループ内部では少しずつ状況が変化しており,「全く同じ」処理を繰り返すことだけがループではありません.そして,条件に応じてループを終了します.ループは本質的には条件分岐命令とジャンプです.

このようなループは「いつループを脱する条件を評価するか」という違いによっていくつかの制御構造があります.

\subsection{\texttt{FOR}文}
\teremp[\texttt{FOR}文]は最もスタンダードなループです.しかし,その内容は初期化・条件・増分を記述する\terlogy{C}系とイテラブル（後述）を走査する\terlogy{Python}系に分かれます.\footnote{これは正式な分類ではありません.}\terlogy{C}のかわりに\terlogy{Java}を用いた例を以下に示しました.

\begin{zennwt}{Javaの例}
  \begin{lstlisting}[language=myjava]
// for ([初期化]; [条件文]; [増分]) {[処理]}
for (int i = 0; i < 10; i++) {
  System.out.println((i + 1) + "回目のおはよう");
}
\end{lstlisting}
\end{zennwt}

\begin{zennwt}{Pythonの例}
  \begin{lstlisting}[language=mypy]
# for [変数] in [イテラブル]: [処理]
for i in range(5):
  print(str(i + 1) + "回目のおはよう")
\end{lstlisting}
\end{zennwt}

この2つのコードはどちらとも「1回目のおはよう 2回目のおはよう (中略) 10回目のおはよう」と出力するコードです。\terlogy{FOR文}の最大の特徴は「\teremp[カウンタ変数]をもつ」ということです。カウンタ変数とはループ毎で変化する変数でループの内部の処理にバリエーションをもたらすものです。上の例では\terlogy{i}が\terlogy{n - 1回目}のループを表すカウンタ変数です。
\\\\
\terlogy{C}系ではこのカウンタ変数の初期化をはじめに記述します。条件文には真偽値をもちいてループを続ける条件を記述しますが、この評価はループの最初に行われます。イメージとしては2行目と3行目の間です。そして、増分と表している部分には通常はカウンタ変数の変化を記述します。ここを\terlogy{i += n}としたり\terlogy{i -= n}とすることでカウンタ変数\terlogy{i}の変化度合いを変えることができます。これは、ループの最後に行われ、イメージは3行目と4行目の間です。
\\\\
\terlogy{Python}系はイテラブルを走査する形で\terlogy{FOR文}をループします。\teremp[イテラブル][iterable]とは連続して複数の値を格納している、または繰り返し可能な性質を指し、そのような性質をもつ型、あるいは変数をはじめとした様々なデータ自体のことも指します。\terlogy{FOR文}はイテラブルから値を一つずつ取り出し、それをカウンタ変数に代入しループします。\terlogy{Python}の場合、\terlogy{range(n)}という関数が用意されており、\terlogy{0, 1, 2, ..., n - 1}のn個の整数の羅列\footnote{正確に言うと\terlogy{range型}という型でイテラブルです。}を返してくれます。イテラブルであれば数字でなくてもいいので、カウント回数を数える必要がなくなります。
\\\\
このように見ると\terlogy{Python}系のほうが圧倒的にわかりやすく、書きやすいようにみえます。実際、実務で\terlogy{FOR文}を使用する際はイテラブルなデータに基づき、個々のデータについての処理を行うことが多く、後者の書き方の方が好まれています。なので\terlogy{C}系の書き方を基本としている言語でも\teremp[拡張\texttt{FOR}文]として\terlogy{Python}系の書き方をサポートしている言語が多いです。

\subsection{\texttt{WHILE}文・\texttt{DO-WHILE}文}
\teremp[\texttt{WHILE}文]は条件を満たす限り半永久的にループし続けます。その際、カウンタ変数を伴わないので、\terlogy{FOR文}よりも簡単に記述できます。

\begin{zennwt}{重複しないランダムな数字を出力する}
  \begin{lstlisting}[language=mypy]
import random # randint関数を使用するため

numbers = [1, 7, 3]
# while [条件文]: [ブロック]
rand = -1
while (rand < 0) or (rand in numbers):
  rand = random.randint(0, 10) # 0 ~ 10でランダムな整数をrandに代入
print(rand)
\end{lstlisting}
\end{zennwt}

このコードは\terlogy{1, 3, 7}以外で0から10のランダムな整数を表示するプログラムです。\terlogy{WHILE文}は条件をループの最初---つまり上の例では6行目と7行目の間で評価しループに入るかどうかを決めます。

上のコードのようにカウンタ変数を使わない「何度も試行する」場合に適しています。また、条件文に\terlogy{True}を指定することで無限ループを作り出すことが可能です。

\begin{zenn}
  \begin{lstlisting}[language=mypy]
while True:
  user_input = input("数字を入力してください: ")
  if user_input.isdigit():
    number = int(user_input)
    print(f"入力された数字は {number} です。")
    break
  else:
    print("数字を入力してください。")
\end{lstlisting}
\end{zenn}

2行目では「標準入力」を要求しています。今は単にキーボードからの入力を受け付けて\terlogy{user_input}に代入しています。\terlogy{.isdigit()}は入力された内容が数字かどうか判別しています。数字であればループを抜けます。でなければループを続けます。ループは\terlogy{SWITCH文}と同様に\terlogy{break}で抜けることができます。このように、\terlogy{WHILE文}は単純なループを構成するのに最適です。
\\\\
ここで、上の「重複しないランダムな数字を出力する」例で少し変な実装をしていると感じた人もいると思います。最初に\terlogy{rand}に\terlogy{-1}を初期化しており、条件に\terlogy{rand < 0}を含めています。なぜこのような実装にしているのかと言いますと\terlogy{WHILE文}は条件を一番最初に評価します。なので、必ず1回は試行をするように1回目にのみ\terlogy{True}となる条件を追加したのです。
\\\\
このような状況をより簡単に記述するために一部の言語には\teremp[\texttt{DO-WHILE}文]が用意されています。例えば\terlogy{JavaScript}では下のように書けます。

\begin{zenn}
  \begin{lstlisting}[language=myjava]
// do { [ブロック] } while ( [条件文] )
do {
  rand = Math.floor(Math.random() * 11);
} while (numbers.includes(rand));
\end{lstlisting}
\end{zenn}

\terlogy{Math.random()}は0以上1未満の浮動小数点数をランダムに出力します。\terlogy{Math.floor}は与えられた浮動小数点数の小数部分を切り捨てして整数を返します。肝心の\terlogy{DO-WHILE文}は条件文をループの最後に評価するので\terlogy{FOR文}や\terlogy{WHILE文}とは違い最低でも一回はブロックを実行します。\terlogy{Python}にはありません。

\section{サブルーチン・関数（メソッド）}
プログラムの命令の集まりは\teremp[ルーチン]と呼ばれると述べました。そのうち、プログラムの「主」となる\teremp[メインルーチン]と対比し、機能的に命令をまとめたルーチンを\teremp[サブルーチン]といいます。メインルーチンはサブルーチンを呼び出す側ということです。また、多くの言語でサブルーチンを\teremp[関数][function]という機能で実現します。
\\\\
関数という名前で最も有名なのは数学における関数でしょう。$y = f(x)$という関数があった場合、$x$が決まれば$y$も決まります。また、$y = f(x_1, x_2, ..., x_n)$といった$n$次元関数（$n$は非負整数）では、$x_1$から$x_n$までが決まれば$y$が決まります。複数の情報を渡し、情報が返ってくるのが関数と言えます。数学の関数とプログラミングの関数は大方同じです。渡す情報を\teremp[引数（ひきすう）]、帰ってくる情報を\teremp[戻り値（もどりち）]といいます。ただ、数学の関数と異なる点として「戻り値はなくても構わない」「引数と戻り値はすべての型を扱える」という2点があります。また、クラス（後述）内に定義される関数を\teremp[メソッド][method]といい、関数とほぼ同じ意味で使われます。
\\\\
サブルーチンは制御構造から考えるとジャンプ命令になります。ただ、実行が終わると元の場所に再びジャンプします。つまり、「戻ってくるジャンプ命令」という言い方ができます。
\\\\
関数は下のように定義することができます。\terlogy{Python}と\terlogy{Java}での例を見ましょう。


\begin{zennwt}{Javaの例}
  \begin{lstlisting}[language=myjava]
// [戻り値の型] [関数名] ([引数1の型] [引数1], [引数2の型] [引数2]) { [ブロック] }
int add(int x, int y) {
  return x+y;
}
\end{lstlisting}
\end{zennwt}

\begin{zennwt}{Pythonの例}
  \begin{lstlisting}[language=mypy]
# def [関数名]([引数1], [引数2]): [ブロック]
def add(x, y):
  return x+y
\end{lstlisting}
\end{zennwt}

関数自体の型というものがあるならばそれは戻り値の型といえます。「この関数はこんな型の値を返します」という指標になります。\terlogy{Java}は静的型付け言語なので関数定義で引数と戻り値の型を明記します。一方、動的型付け言語である\terlogy{Python}は実行中に型検査をするので関数定義で引数と戻り値の型を明記しません。引数で定義された変数は関数内で使用できます。\footnote{関数外で使用できるかどうかは関数スコープを持っているかによりますが、多くの言語では関数スコープを持ち、引数は関数内でのみに制限されます。}また、\terlogy{return}（後述）は次に記述した値を戻り値として返し、その時点で呼び出し元にジャンプし、関数のそれ以降は実行しません。
\\\\
また、上の例では引数は2つだけ設定しましたが、何個でも設定できます。複数の場合は\terlogy{,}（カンマ）で区切ります。引数が0個の場合は\terlogy{()}の中はなにも書きません。
\\\\
定義した関数は使わなければ意味がありません。関数を実行する---これを呼び出すあるいは叩くといういいかたをします---には次のように記述します。

\begin{zenn}
  \begin{lstlisting}[language=mypy]
# [関数名]([引数1], [引数2])
ans = add(15, 16)
print(ans)

# 実行結果：31
\end{lstlisting}
\end{zenn}

定義と同じ数だけ引数を渡す必要があります。\terlogy{Python}と\terlogy{Java}では引数の順番をもって「どれがどの引数となるのか」という紐づけを行うので上の例では\terlogy{15}が\terlogy{x}で\terlogy{16}が\terlogy{y}となります。

\section{早期脱出・終了命令}
\teremp[早期脱出・終了命令]を使用してループやサブルーチンの自然終了---ブロックなどの最終命令まで実行が終了し、フローが通常の状態に戻ること---を待たずして早期に脱出することができます。

\subsection{\texttt{return}}
\terlogy{return x}の形で関数の戻り値として\terlogy{x}を指定しその場でサブルーチンを終了します。この記述以降のすべての命令は実行されません。また、戻り値を返さないとき、\terlogy{return}のみ書きます。

\begin{zenn}
  \begin{lstlisting}[language=mypy]
def add(x, y):
  # return [戻り値]
  return x+y

def sendMes(message):
  if message == "":
    return
  print(message)
\end{lstlisting}
\end{zenn}

上のように\terlogy{IF文}とともに使うことで条件に応じて複数通りの\terlogy{return}を行うこともできます。

\subsection{\texttt{break}}
今実行している直属のループ命令と\terlogy{SWITCH文}から抜け出します。該当制御構造の中の命令はその後、一切実行しません。また、別の制御構造---主に\terlogy{if文}---で実行する際は入れ子関係を遡り最初に存在するループ命令か\terlogy{SWITCH文}を探し、そこから脱出します。

\subsection{\texttt{continue}}
今実行している直属のループ命令について現在実行しているループを終了し、次のループを始めます。また、別の制御構造で実行する際は入れ子関係を遡り最初に存在するループ命令を探し、そのループを進めます。

\begin{zenn}
  \begin{lstlisting}[language=mypy]
for i in range(0, 11):
  if i % 2 == 0:
    continue
  print(i)

# 実行結果
# 1
# 3
# 5
# 7
# 9
\end{lstlisting}
\end{zenn}

上のコードはカウンタ変数\terlogy{i}が「2で割ったときの余りが0」つまり「2の倍数」となっている場合はすぐにループを進め、そうでない場合のみ\terlogy{print()}しています。

\subsection{多重ループにおける\texttt{break}と\texttt{continue}}
複数のループ命令を入れ子関係で連ねることを\teremp[多重ループ]といいます。\terlogy{break}は内側のループで実行するとそのループだけを抜け出します。\terlogy{Java}例を見てみましょう。

\begin{zenn}
  \begin{lstlisting}[language=myjava]
// 外ループ
for (int i = 0; i < 3; i++) {
  // 内ループ
  for (int j = 0; j < 10; j++) {
    if (i < j) {
        break;
    }
    System.out.println(i + " " + j);
  }
}

// 実行結果
// 0 0
// 1 0
// 1 1
// 2 0
// 2 1
// 2 2
\end{lstlisting}
\end{zenn}

わかりやすさのため、カウンタ変数が\terlogy{i}となってる\terlogy{FOR文}を外ループ、カウンタ変数が\terlogy{j}となってる\terlogy{FOR文}を内ループと呼ぶことにします。実行結果から分かる通り、内ループの内にある\terlogy{break}は内ループのみを抜け出しています。
\\\\
しかし、内ループ内から外ループを抜けることもできます。\terlogy{Java}では\terlogy{FOR文}にラベルをつけることで直属より上の\terlogy{FOR文}を抜けることができます。\footnote{\terlogy{Python}ではできません。}

\begin{zenn}
  \begin{lstlisting}[language=myjava]
outer:
for (int i = 0; i < 10; i++) {
  inner:
  for (int j = 0; j < 10; j++) {
    if (i < j) {
        break inner;
    }
    if (i*j > 10) {
      break outer;
    }
    System.out.println(i + " " + j);
  }
}

// 実行結果
// 0 0
// 1 0
// 1 1
// 2 0
// 2 1
// 2 2
// 3 0
// 3 1
\end{lstlisting}
\end{zenn}

外ループには\terlogy{outer}、内ループには\terlogy{inner}というラベル---つまり名前をつけ、\terlogy{break [ラベル名]}ので指定した\terlogy{FOR文}を抜けています。\terlogy{WHILE文}や\terlogy{DO-WHILE文}も同様にラベルをつけることが可能です。

\Chapter{オブジェクト指向}
\section{オブジェクト指向とは}
\teremp[オブジェクト指向][object-oriented]とはプログラミング言語やシステムの構築や設計のための考え方の1つです。現代では、プログラムを「モノ=\teremp[オブジェクト][object]」というモデルに分割し、オブジェクト間の相互関係を定義することでシステムを構築しようとすることを指します。複雑なシステムを管理しやすくしたり、プログラムを再利用できるという利点があるために、ほとんどの言語で採用されており現代のシステムではオブジェクト指向言語によってその殆どが構成されています。
\\\\
オブジェクト指向という言葉は元々、史上初のオブジェクト指向プログラミング言語「Smalltalk」の開発者である\teremp[Alan Kay]の造語であり、オブジェクト同士が互いに作用し合うという「メッセージング」という考え方が主な意味でした。当時はGUIとプログラムの関係がとても重視されており、Kayは非データ手順というものを重視していました。これは宣言と解釈という関係と言えます。「具体的にどうするか」を記述するのではなく「必要な要素及び属性」を記述し、その解釈をオブジェクトが行うという考え方です。
\\\\
しかし、世間はそういった考え方でなくそれを実現するためのオブジェクトという概念に注目しました。現代では\teremp[データ]とそれを解釈---より広い意味で言えば実行する\teremp[プロセス]とを一体化したものこそがオブジェクトなのです。こういったオブジェクトは多くの言語で\teremp[インスタンス][instance]とよばれ、それを定義する構造を\teremp[クラス][class]といいます。
\\\\
現代のクラスは以下の3つの特徴を持っています。

\begin{itemize}
  \item \teremp[カプセル化]：先程述べたデータとプロセスを一体化して管理するという手法。また、外部から一部のデータを保護し、特定の窓口からでしかアクセスできないようにする\teremp[情報隠蔽]という機能としても機能している。
  \item \teremp[継承・拡張][inheritance/extension]：あるクラスをベースに機能を付け加えたりしてより複雑なクラスを定義すること。先人が作ったものを簡単にカスタムして使うことができるため、「プログラムを再利用する」ことができる。
  \item \teremp[ポリモーフィズム][polymorphism]：たとえ、別のクラスであっても継承関係がなりたっておりその要素（後述）が同じであれば同一のクラスとみなして使用することができる。
\end{itemize}

継承とポリモーフィズムについては詳しく後述します。

\section{クラス}
先節でも述べた通り、クラスはインスタンス---つまりはオブジェクトの定義元です。「設計図」という言い方が広く知られています。プログラマはまずクラスを定義し、それをインスタンスにしなければなりません。なぜならインスタンスが実行されるオブジェクト本体だからです。（つまりクラスを実行するという言い方は厳密には間違いです。）インスタンスをクラスから生成することを\teremp[インスタンス化]といいます。設計図の例を用いるならば設計図をもとに部品や製品を製造するということになります。インスタンス化は同じクラスに対して複数行うことができ、一つのクラスから、複数のインスタンスが生成できます。これも「プログラムを再利用する」ということになります。
\\\\
クラス及びそこから生成されるインスタンスには次のような要素を持ちます。

\begin{itemize}
  \item \teremp[メンバ変数（フィールド）]：クラス内直下に定義される変数で、そのクラスやインスタンスの「属性」や「設定」を表す場合が多い。オブジェクト指向でいう「データ」に値する。
  \begin{itemize}
    \item \teremp[クラス変数]：クラスを通じて同じものが定義されているメンバ変数。一般的には定数を用いることが多い。
    \item \teremp[インスタンス変数（属性）]：インスタンスごとに違うものが代入されてるメンバ変数。一般的にメンバ変数と表記する場合もある。
  \end{itemize}
  \item \teremp[メソッド（メンバ関数）]：クラス内直下に定義される関数で、そのクラスやインスタンスの「機能」を表す場合が多い。オブジェクト指向でいう「プロセス」に値する。
  \begin{itemize}
    \item \teremp[コンストラクタ]：クラスがインスタンス化された際に実行される処理。主にメンバ変数---特にインスタンス変数の初期化を行う場合が多い。
  \end{itemize}
\end{itemize}

では\terlogy{Python}でのクラスの定義方法を見てみましょう。

\begin{zenn}
  \begin{lstlisting}[language=mypy]
# class [クラス名]:
class People:
  # コンストラクタ
  def __init__(self, name, age):
    self.name = name
    self.age = age

  # メソッド
  def greet(self):
    print("こんにちは、私の名前は" + str(self.name) + "です。年齢は" + str(self.age) + "歳です。")
\end{lstlisting}
\end{zenn}

上のコードでは\terlogy{People}という名前のクラスを定義しています。\terlogy{Python}では\terlogy{__init__}という名前のメソッドが自動的にコンストラクタとなります。\terlogy{self}は自分のクラスを指すもので、\terlogy{self.name}と\terlogy{self.age}はメンバ変数にあたります。メソッドは関数と同じように定義することができます。
\\\\
では次はこのクラスを使ってみましょう。

\begin{zenn}
  \begin{lstlisting}[language=mypy]
# クラスのインスタンス化
# [クラス名]([コンストラクタへの引数])
tarou = People("太郎", 25)

# メソッドの呼び出し
# [インスタンスの変数名].[メソッド名]([メソッドへの引数])
tarou.greet()

# 実行結果：こんにちは、私の名前は太郎です。年齢は25歳です。
\end{lstlisting}
\end{zenn}

メソッドへの引数では\terlogy{self}は渡す必要がないので上のコードではインスタンス化時に引数を2つしか渡していません。\terlogy{greet()}でも引数を渡してません。メソッドの呼び出しには必ずインスタンスを用いる必要があり、指定してからメソッドを記述しなければなりません。初心者によくある間違いとしてクラスを指定してしまうことがありますがクラスは設計図ですのでインスタンスではありません。インスタンスは通常の値と同じように変数に格納し、変数として扱うことができます。この際、変数の型は「クラス」になります。クラスを定義するということは、型を定義するということでもあるのです。

\section{継承とポリモーフィズム}
\teremp[継承][inheritance/extension]とはクラスの特性（データ・プロセスなど）を引き継いだクラスを定義することを指します。継承元のクラスを\teremp[スーパークラス][super class]\teremp[基底クラス][base class]\teremp[親クラス][parent class]、継承して作られるクラスを\teremp[サブクラス][subclass]\teremp[派生クラス][derived class]\teremp[子クラス][child class]といいます。スーパークラスの記述はすべてサブクラスに引き継がれるので、クラスを継承するだけでコードを書かなくてもスーパークラスの機能を実装できます。また、スーパークラスのメソッドをサブクラスで定義し直すことを\teremp[オーバーライド][override]といい、オーバーライドすることで機能のカスタムをすることもできます。この2点から複雑な機能を簡単に実装することができます。

\begin{zenn}
  \begin{lstlisting}[language=mypy]
# class [クラス名]([スーパークラス名]):
class Robot(People):
  def __init__(self, name, age, number):
    super().__init__(name, age)
    self.number = number

  def greet(self):
    super().greet()
    print("ただしロボット" + str(self.number) + "号です。")


robot_tarou = Robot("太郎", 26, 5)
robot_tarou.greet()

# 実行結果
# こんにちは、私の名前は太郎です。年齢は26歳です。
# ただしロボット5号です。
\end{lstlisting}
\end{zenn}

スーパークラスを継承した時点でメソッドなどは実装され、記述する必要はありませんが上では\terlogy{override}して機能を改変しています。\terlogy{super()}はスーパークラスを指し、\terlogy{super().[メソッド名]([引数])}でスーパークラスで定義されたメソッドを実行しています。つまりは、上の例ではメソッドを書き直しているのではなく、書き加えています。もちろん、\terlogy{super().[メソッド名]()}を書かなければスーパークラスの機能は全く継承しないことになります。サブクラスにメソッドを書いた時点でスーパークラスの記述は無視されるのです。上の例ではコンストラクタに引数\terlogy{number}を追加し、残り2つはスーパークラスに準じています。また、\terlogy{greet()}では出力内容を増やしています。
\\\\
また、スーパークラスとサブクラスの関係には\teremp[ポリモーフィズム][polymorphism]という考え方が採用されており、たとえ振る舞い---実行内容など---が異なっていても同等に扱うことができます。例えば、スーパークラスはサブクラスに型安全的\footnote{型システムが正常に運用される状態のこと。}に代替できるという\teremp[サブタイピング][subtyping]がこれに含まれます。動的型付け言語ではサブタイピングがわかりにくいので静的型付け言語である\terlogy{Java}の例を見てみましょう。

\begin{zenn}
  \begin{lstlisting}[language=myjava]
People robotTarou = new Robot("太郎", 26, 5);
robotTarou.greet();

// 実行結果
// こんにちは、私の名前は太郎です。年齢は26歳です。
// ただしロボット5号です。
\end{lstlisting}
\end{zenn}

\terlogy{new}とはインスタンス化する際の\terlogy{Java}での記述です。\terlogy{robotTarou}の型は\terlogy{People}であるにも関わらず\terlogy{Robot}型のインスタンスを代入しています。これは\terlogy{People}が\terlogy{Robot}のスーパークラスだからです。これは関数の引数として渡すときにより効果を発揮します。

\begin{zenn}
  \begin{lstlisting}[language=myjava]
// greet()を実行する関数を定義
void sayHello(People instance) {
  instance.greet();
}

sayHello(new Robot("太郎", 26, 5));

// 実行結果
// こんにちは、私の名前は太郎です。年齢は26歳です。
// ただしロボット5号です。
\end{lstlisting}
\end{zenn}

関数の定義では\terlogy{People}型を要求していますが、実際には\terlogy{Robot}型を渡しています。このように、「継承関係で振る舞いが一致していれば別クラスでも構わない」というのがポリモーフィズムの特性なのです。

\Chapter{データ構造}
コンピュータには大量のデータ---いわゆるビッグデータもその一つですが---を扱うという利点があります。しかし、それらのデータを処理するアルゴリズムや具体的なコードは「一般化」されたものです。つまり、データの内容に関わらずいつでも同じように処理されるのです。この場合、正しくデータを処理するためにはデータの内容ではなくデータの形式---形を統一しなければなりません。そしてそれ処理する方法も統一されなければなりません。このように、データを効果的に管理するための仕組みや方法を\teremp[データ構造][data structures]といいます。そして、データ構造のうち、複数のデータをまとめたものを\teremp[コンテナ][container]といいます。データ構造やコンテナにはそれぞれ長所や短所があり、その場合によって使い分けるべきです。データ構造を学ぶことで、プログラミングの原点である「データ」について深く理解できるようになります。
\\\\
ここで\teremp[計算量]という指標を導入したいと思います。計算量とはアルゴリズムやプログラムが処理を行う際に必要な計算の量やリソースの使用量を表す概念です。アバウトにいえば、「そのアルゴリズムが処理を終えるのにかかる時間」ということになります。計算量は$\mathcal{O}(f(n))$という形で表します。$f(n)$は要素数$n$についての関数で計算量がこの関数に比例することを表しています。なので正確には計算量は「そのアルゴリズムが処理を終えるのにかかる時間が要素数によってどのように増えるのか」を表したものになります。一般的に関数が小さいほど「計算量は小さく」、「優れたアルゴリズム」といえます。

\begin{column}{ランダウの記号}
  計算量で使用する$\mathcal{O}$は\teremp[ランダウの記号]や\teremp[$\mathcal{O}-$記法]と言われ、数学的な定義が存在するれっきとした数学記法です。定義は、十分に大きい$x$について関数$f(x)$が関数$g(x)$に比例またはそれ以下に抑えられるとき、$f(x) = \mathcal{O}(g(x))$と表せます。これを数式に直すと以下のようになります。
  \begin{equation*}
    f(x) = \mathcal{O}(g(x)) \qquad \Longleftrightarrow  \qquad \exists x_0, \exists c > 0 \quad s.t. \quad \forall x > x_0, \> f(x) \leqq c \cdot g(x)
  \end{equation*}
  一般的に$g(x)$は最もシンプルな形で表され、この場合$f(x)$の「最高次の項を取り出し、定数を取り除く」といった作業で$g(x)$を求めることができます。つまり、$3x^3+2x^2+5x+1 = \mathcal{O}(x^3)$となります。
\end{column}

\section{線形データ構造}
\teremp[線形データ構造][linear data structures]はデータが線形で保存されるデータ構造です。つまり、個々のデータは最初と最後の要素を除き、前の要素と次の要素を持ちます。
\subsection{配列（Array）}
\teremp[配列][Array]は最も基本的な線形データ構造で、要素の集まりです。各要素は一般的にインデックスという数字でアクセスが可能です。配列は連続したメモリ上に一括で保存され、その特性上サイズ---多くの場合、要素数---を変更することが困難になります。その代わり、インデックスを用いた要素へのアクセスは走査する必要がなく、計算量は$ \mathcal{O}(1)$になります。


\begin{column}{可変長な配列}
  一部の言語では可変長---つまりサイズが容易に変更可能な配列をサポートしています。これらの言語では地蔵的にメモリを確保する仕組みが備わっています。「配列」として言語に実装している\terlogy{Javascript}や\terlogy{Python}といった言語や標準ライブラリのクラスの一つとして「配列」とは別に提供している\terlogy{C++}や\terlogy{Java}といった言語もあります。
\end{column}

\subsection{連結リスト（Linked List）}
\teremp[連結リスト][Linked List]は表面的には配列と一致しており、インデックスでアクセスな可能な線形データ構造の一つです。ただ、そのデータは必ずしも連続したメモリに保存されているわけではなく、まばらに保存されています。そのため、個々のデータには次のデータか前のデータ、あるいはその両方の所在---多くの場合、メモリ上での所在---が保存されています。そのため、サイズの変更が容易ですが、インデックスを用いたアクセスでも計算量は$\mathcal{O}(n)$となります。単に\teremp[リスト][List]と呼ばれることもあります。

\subsection{スタック（Stacks）}
\teremp[スタック][Stacks]は\teremp[後入れ先出し][LIFO; Last In First Out]の原則に従う原始的な線形データ構造です。皿を縦に積み上げることを考えてください。一番最後においた皿から取り出さなければなりませんよね。これがLIFOです。現在はアプリケーションのやり直し（\texttt{Ctrl + Z}）などのアルゴリズムの一部となっています。スタックは取り出しや追加の位置が決まっているので計算量はいずれも$\mathcal{O}(1)$です。

\subsection{キュー（Queues）}
\teremp[キュー][Queues]は\teremp[先入れ先出し][FIFO; First In First Out]の原則に従う原始的な線形データ構造です。店先で並ぶことを考えてください。先に並んだ客から店に入ることができます。これがFIFOです。現在は印刷ジョブキューなどのジョブ管理や再帰関係を管理することに使われています。キューも同様に、追加も取り出しも計算量は$\mathcal{O}(1)$です。

\section{非線形データ構造}
\teremp[非線形データ構造][non-linear data structures]はデータがより複雑な形となっており、階層という概念を持ったデータ構造です。複雑になる一方データの関係を簡潔に整理できますが、計算量が大きくなる傾向があります。

\subsection{木構造（Trees）}
\teremp[木構造][Trees]はデータが親子関係にあり、再帰的につながることで木の枝のように分岐するデータ構造です。組織図や家系図などがわかりやすいでしょう。データの基本単位を\teremp[ノード][Node]といい、親子の2つのノードを\teremp[エッジ][Edge]でつなぎます。一番親のノードを\teremp[ルート][Root]といい、すべての探索はここから始めます。非常によく使われ、\terlogy{OS}のファイルシステム---ディレクトリの中にファイルやディレクトリが存在するようなデータの保存方法---はこれに当たります。また、本書のように\terlogy{章 > 節 > 項}のような「章立て」も木構造といえます。

\subsection{グラフ（Graph）}
\teremp[グラフ][Graph]は木構造のようにノードやエッジをもったデータ構造です。しかし、親子関係は存在せず一つのノードは複数のエッジを持ちます。ノードを頂点、エッジを辺と表現することでこのデータ構造はポリゴンを表現しているとも言えます。人物の交友関係やシステムの依存関係、交通ネットワークの表現に使用されます。路線図などがいい例です。

\subsection{集合・セット（Set）}
値をただ集合として扱い、順序や相関関係のない状態で保存するには\teremp[集合・セット][Set]を使います。セット内では順序が存在せず、重複した値は許可されません。このデータ構造の最大の利点は、セット同士の和集合、積集合、差集合をとる操作が容易に行なえることです。また、セット内に任意の値が存在するかの確認がすぐに行えることも利点と言えます。例えば、参加者の名簿などはセットで実装することが望まれます。\footnote{セットは、あまり使用されない傾向にありますが、述べたように様々なメリットが存在するので積極的に使用するべきだと私個人として思います。}

\section{連想データ構造}
\teremp[連想データ構造]は\teremp[キー][Key]と\teremp[値][Value]を紐づけたデータ構造です。

\subsection{連想配列（Associative Array）}
\teremp[連想配列][Associative Array]は最も基本的な連想データ構造でキーと値が紐づけされたデータ構造を指します。ほとんどの言語では連想データ構造の代表的存在として実装あるいはライブラリとして用意されていますが、すべての連想データ構造を指して使われることがあります。また、言語によっては他の連想データ構造の機能を複数備えたものになっており、言語によって呼び方も「辞書」「マップ」などと大きく違います。

\subsection{ハッシュマップ・ハッシュテーブル（Hash Map/Hash Table）}
\teremp[ハッシュマップ][Hash Map]と\teremp[ハッシュテーブル][Hash Table]はほぼ同じもので、指定されたキーを\teremp[ハッシュ関数]を用いて\teremp[ハッシュコード]に変換し、配列のインデックスに使用するデータ構造です。実質にはただの配列ですが、ハッシュ関数を使うことで任意の値をキーにすることができ、コードの可読性や構造の把握のしやすさを上げることができます。多くの場合、連想配列の実装方法の一つとして扱われます。

\subsection{マルチマップ（Multi Map）}
\teremp[マルチマップ][Multi Map]は一つのキーについて複数の値が取れるデータ構造です。通常、連想配列とセット/配列などを併用して実装します。

\section{複合データ構造}
様々なデータ構造複合したデータ構造を\teremp[複合データ構造][Composite Data Structures]といいます。

\subsection{構造体・レコード（Struct）}
複数のデータを格納するためのクラスによく似た構造を\teremp[構造体・レコード][Struct]といいます。クラスにおけるメンバ変数のようにデータを格納でき、定義時点ではクラス同様に「設計図」です。構造体をインスタンス化することで使用することができます。見かけ上、構造体は連想配列です。キーがメンバ変数名で値がメンバ変数です。ただ、連想配列とは違ってあとからキーを増やしたり、変えることはできません。さらに、インスタンス化することで同じ構造体を繰り返し用いることができます。なので、構造体は決められた項目を繰り返すような構造に使用されることが多く、人物のプロフィールやキャラクターのステータスは構造体を使用することが好まれます。一部の言語ではクラスと同じようにメソッドを追加できることがありますが、詳しくは次節のコラムにてクラスとの違いを説明します。

\subsection{クラス（Class）}
クラスも構造体のかわりとして使用することができます。構造体が実装されている言語では好まれませんが、構造体が存在しない言語---例えば\terlogy{Java}など---ではクラスをかわりに使用します。

\begin{column}{構造体とクラス}
  構造体とクラスを用意する言語がありますが、この2つにはどんな違いがあるのでしょうか。違いは2つあります。

  \begin{enumerate}
    \item カプセル化\\
    構造体のメンバ変数は外部から出し入れするためのものですので、情報隠蔽やアクセス制限は基本的に行いません。
    \item 値コピーと参照コピー\\
    クラスはプリミティブ型ではなく参照型なので、クラスのインスタンスがコピーされたときは参照がコピーされます。それに対して、構造体はプリミティブ型のような値コピーを行うので、構造体をコピーした際、インスタンスは別値として扱われます。
  \end{enumerate}

  やはり注目すべきは構造体は値コピーである点です。インスタンスをコピーして値を編集しても他方に影響しないのです。クラスは影響してしまいます。また、一部の言語では構造体にメソッドが用意されていません。用意されている言語では、クラスと同じようにメソッドを記述することができ、「プロセス」を実装することもできます。また、クラスと同様に継承を行うこともできます。ただ、これらの機能は言語における構造体の定義や考え方に依存しています。
\end{column}

\end{document}